<?xml version="1.0" encoding="UTF-8"?>
<!--

  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

-->
<apiPackage id="mx.managers"><apiName>mx.managers</apiName><apiDetail/><apiClassifier id="mx.managers:HistoryManager"><apiName>HistoryManager</apiName><shortdesc>
  借助历史记录管理，用户可以使用 Web 浏览器的“后退”和“前进”导航命令在 Flex 应用程序中导航。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
  借助历史记录管理，用户可以使用 Web 浏览器的“后退”和“前进”导航命令在 Flex 应用程序中导航。 
  
  <p>通常情况下，应使用 BrowserManager 类和深层链接来维护应用程序中的状态并处理 URL 和浏览器历史记录，但 HistoryManager 类在某些情况下会很有用，如维护旧版 Flex 应用程序时。无法在同一个 Flex 应用程序中同时使用 HistoryManager 类和 BrowserManager 类，即使二者使用同一组支持文件也不例外。</p>
  
  <p>默认情况下，对 Accordion 和 TabNavigator 容器启用历史记录管理功能。这意味着，如果用户选择了 Accordion 控件中的某个窗格，则可以使用浏览器的“后退”按钮或后退导航命令返回到前一个窗格。默认情况下，对 ViewStack 导航器容器禁用历史记录管理功能。</p>
  
  <p>可通过将导航器容器的 <codeph>historyManagementEnabled</codeph> 属性设置为 <codeph>false</codeph> 来禁用历史记录管理。</p>
  
  <p>还可以向 HistoryManager 注册应用程序中的其他对象，从而对这些对象启用历史记录管理功能。要向 HistoryManager 类注册一个组件，需要调用 HistoryManager 类的 <codeph>register()</codeph> 方法，同时引用实现 IHistoryManagerClient 接口的组件实例。在以下示例中，在初始化 Application 组件 (<codeph>this</codeph>) 时将向 HistoryManager 类注册此组件：
  <pre>
  &lt;mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" 
    implements="mx.managers.IHistoryManagerClient" 
    initialize="mx.managers.HistoryManager.register(this);">
  </pre>
  还必须实现 IHistoryManagerClient 接口的 <codeph>saveState()</codeph> 和 <codeph>loadState()</codeph> 方法才能完成组件的注册。扩展 UIComponent 的组件会自动继承 <codeph>loadState()</codeph> 方法。</p>
  
  <p>HistoryManager 中的所有方法和属性都是静态的，因此不需要为其创建实例。</p>
 
  </apiDesc></apiClassifierDetail><related-links><link href="mx.managers.xml#BrowserManager"><linktext>mx.managers.BrowserManager</linktext></link><link href="mx.managers.xml#IHistoryManagerClient"><linktext>mx.managers.IHistoryManagerClient</linktext></link></related-links><apiOperation id="mx.managers:HistoryManager:initialize"><apiName>initialize</apiName><shortdesc>
      DEPRECATED — 初始化 HistoryManager。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>sm</apiItemName><apiOperationClassifier>mx.managers:ISystemManager</apiOperationClassifier><apiDesc>用于此应用程序的 SystemManager。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      DEPRECATED — 初始化 HistoryManager。因为每当您使用 <codeph>historyManagementEnabled</codeph> 添加组件时，Flex 都会调用此方法，所以通常情况下无需进行此调用。然而，如果 HistoryManager 不是从顶级应用程序进行的初始化，将无法正常运行。因此，如果应用程序中的所有组件都未启用 HistoryManager，但加载了启用 HistoryManager 的其他子应用程序，则必须在主应用程序中调用 <codeph>HistoryManager.initialize()</codeph> 方法（通常是从该应用程序中的 <codeph>initialize</codeph> 事件处理函数中进行调用）。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:HistoryManager:register"><apiName>register</apiName><shortdesc>
      向 HistoryManager 注册对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>mx.managers:IHistoryManagerClient</apiOperationClassifier><apiDesc>要注册的对象。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      向 HistoryManager 注册对象。此对象必须实现 IHistoryManagerClient 接口。
     
      </apiDesc></apiOperationDetail><related-links><link href="mx.managers.xml#IHistoryManagerClient"><linktext>mx.managers.IHistoryManagerClient</linktext></link></related-links></apiOperation><apiOperation id="mx.managers:HistoryManager:save"><apiName>save</apiName><shortdesc>
      保存应用程序的当前状态，以便以后还原。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      保存应用程序的当前状态，以便以后还原。当导航器容器的导航状态发生更改时，导航器容器会自动调用此方法。如果向 HistoryManager 注册了某个接口，则当应用程序状态发生更改时，您要负责调用 <codeph>save()</codeph> 方法。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:HistoryManager:unregister"><apiName>unregister</apiName><shortdesc>
      撤销向 HistoryManager 注册对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>mx.managers:IHistoryManagerClient</apiOperationClassifier><apiDesc>要撤销注册的对象。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      撤销向 HistoryManager 注册对象。
     
      </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="mx.managers:PopUpManagerChildList"><apiName>PopUpManagerChildList</apiName><shortdesc>
  PopUpManagerChildList 类用于为 PopUpManager addPopUp() 和 createPopUp() 方法的 detail 属性定义常量值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
  PopUpManagerChildList 类可以为 PopUpManager <codeph>addPopUp()</codeph> 和 <codeph>createPopUp()</codeph> 方法的 <codeph>detail</codeph> 属性定义常量值。
  
  </apiDesc></apiClassifierDetail><related-links><link href="mx.managers.xml#PopUpManager"><linktext>PopUpManager</linktext></link></related-links><apiValue id="mx.managers:PopUpManagerChildList:APPLICATION"><apiName>APPLICATION</apiName><shortdesc>
	  指示弹出窗口与应用程序位于相同的子列表中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>application</apiData><apiType value="String"/></apiValueDef><apiDesc>
	  指示弹出窗口与应用程序位于相同的子列表中。
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:PopUpManagerChildList:PARENT"><apiName>PARENT</apiName><shortdesc>
	  指示无论父组件位于哪一个子列表中，弹出窗口都与父组件位于同一子列表中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>parent</apiData><apiType value="String"/></apiValueDef><apiDesc>
	  指示无论父组件位于哪一个子列表中，弹出窗口都与父组件位于同一子列表中。
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:PopUpManagerChildList:POPUP"><apiName>POPUP</apiName><shortdesc>
	  指示弹出窗口位于弹出窗口子列表中，因此它可以浮在应用程序层中其他弹出窗口的上方。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>popup</apiData><apiType value="String"/></apiValueDef><apiDesc>
	  指示弹出窗口位于弹出窗口子列表中，因此它可以浮在应用程序层中其他弹出窗口的上方。
	  
	  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:IFocusManagerComponent"><apiName>IFocusManagerComponent</apiName><shortdesc>
  IFocusManagerComponent 接口用于定义一些接口，可获得焦点的组件必须实现这些接口才能从 FocusManager 获得焦点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
  IFocusManagerComponent 接口用于定义一些接口，可获得焦点的组件必须实现这些接口才能从 FocusManager 获得焦点。UIComponent 类中提供了此接口的基本实现，但 UIComponent 并不实现完整的 IFocusManagerComponent 接口，因为部分 UIComponent 无需获得焦点。因此，要使 UIComponent 派生的组件成为一个可获得焦点的有效组件，只需将“implements IFocusManagerComponent”添加到类定义即可。
  
  </apiDesc></apiClassifierDetail><apiOperation id="mx.managers:IFocusManagerComponent:mx.managers:IFocusManagerComponent:drawFocus"><apiName>drawFocus</apiName><shortdesc>
      当组件获得焦点时，由 FocusManager 调用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>isFocused</apiItemName><apiType value="Boolean"/><apiDesc>如果为 <codeph>true</codeph>，则绘制焦点指示符，否则隐藏它。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      当组件获得焦点时，由 FocusManager 调用。组件应该绘制或隐藏表示组件具有焦点的图形。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IFocusManagerComponent:mx.managers:IFocusManagerComponent:setFocus"><apiName>setFocus</apiName><shortdesc>
      当组件获得焦点时，由 FocusManager 调用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      当组件获得焦点时，由 FocusManager 调用。同样，该组件可以将焦点设置给某个内部组件。
      
      </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:IFocusManagerComponent:mx.managers:IFocusManagerComponent:focusEnabled:get"><apiName>focusEnabled</apiName><shortdesc>
      一个标志，用于指示组件处于选中状态时是否可以获得焦点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/></apiValueDef><apiDesc>
      一个标志，用于指示组件处于选中状态时是否可以获得焦点。
     
      <p>如果组件中的子组件实现了 IFocusManagerComponent 接口，但是您从不希望它获得焦点，作为一种优化，您可以先将 <codeph>focusEnabled</codeph> 设置为 <codeph>false</codeph>，然后再在子组件上调用 <codeph>addChild()</codeph>。</p>
     
      <p>这将使 FocusManager 忽略此组件，并且使它不会对组件进行监视以查看 <codeph>tabFocusEnabled</codeph>、<codeph>hasFocusableChildren</codeph> 和 <codeph>mouseFocusEnabled</codeph> 属性是否发生更改。这也意味着 <codeph>addChild()</codeph> 之后，您无法更改此值，也不能指望 FocusManager 进行监视。</p>
     
      <p>注意：这并不意味着您无法在 <codeph>setFocus()</codeph> 方法中以编程方式使此对象获得焦点；它仅通知 FocusManager 在 Tab 和鼠标搜索中忽略此 IFocusManagerComponent 组件。</p>
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:IFocusManagerComponent:mx.managers:IFocusManagerComponent:hasFocusableChildren:get"><apiName>hasFocusableChildren</apiName><shortdesc conref="mx.core.UIComponent#hasFocusableChildren">
      </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiTool description="" name="Flex" version="4"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/></apiValueDef><apiDesc conref="mx.core.UIComponent#hasFocusableChildren">
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:IFocusManagerComponent:mx.managers:IFocusManagerComponent:mouseFocusEnabled:get"><apiName>mouseFocusEnabled</apiName><shortdesc>
      一个标志，用于当使用鼠标选中组件时组件是否可以获得焦点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
      一个标志，用于当使用鼠标选中组件时组件是否可以获得焦点。如果为 <codeph>false</codeph>，焦点将转移到第一个 <codeph>mouseFocusEnabled</codeph> 父项。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:IFocusManagerComponent:mx.managers:IFocusManagerComponent:tabFocusEnabled:get"><apiName>tabFocusEnabled</apiName><shortdesc>
      一个标志，指示通过按 Tab 键最终是否能够将焦点移动到此组件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiTool description="" name="Flex" version="4"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
      一个标志，指示通过按 Tab 键最终是否能够将焦点移动到此组件。即使为 <codeph>false</codeph>，您也可以通过使用鼠标进行选择或通过调用 <codeph>setFocus()</codeph> 获得焦点。此属性替换 InteractiveObject.tabEnabled，后者在 Flex 应用程序中必须设置为 true。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:IFocusManagerComponent:mx.managers:IFocusManagerComponent:tabIndex:get"><apiName>tabIndex</apiName><shortdesc>
      如果 tabFocusEnabled 为 true，则为组件获得焦点的顺序。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="int"/></apiValueDef><apiDesc>
      如果 <codeph>tabFocusEnabled</codeph> 为 true，则为组件获得焦点的顺序。如果为 -1，则组件按 z 轴顺序获得焦点。
      
      </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:BrowserManager"><apiName>BrowserManager</apiName><shortdesc>
  BrowserManager 是一个 Singleton 管理器，用于充当浏览器和应用程序之间的代理。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
  BrowserManager 是一个 Singleton 管理器，用于充当浏览器和应用程序之间的代理。使用它可以访问浏览器地址栏中的 URL，这与访问 JavaScript 中的 <codeph>document.location</codeph> 属性类似。当 <codeph>url</codeph> 属性发生更改时分派这些事件。然后侦听器可以响应、更改该 URL 和/或阻止其他对象获取此事件。 
 
  <p>要使用 BrowserManager，则需要调用 <codeph>getInstance()</codeph> 方法获取管理器的当前实例，并调用一些方法来侦听该管理器上的事件。有关要使用的方法、属性和事件，请参见 IBrowserManager 类。</p>
 
  </apiDesc></apiClassifierDetail><related-links><link href="mx.managers.xml#IBrowserManager"><linktext>mx.managers.IBrowserManager</linktext></link><link href="mx.managers.xml#HistoryManager"><linktext>mx.managers.HistoryManager</linktext></link></related-links><apiOperation id="mx.managers:BrowserManager:getInstance"><apiName>getInstance</apiName><shortdesc>
      返回此 Singleton 类的唯一实例；如果不存在这样的实例，则创建一个。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>返回此 Singleton 类的唯一实例；如果不存在这样的实例，则创建一个。
      
      </apiDesc><apiOperationClassifier>mx.managers:IBrowserManager</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      返回此 Singleton 类的唯一实例；如果不存在这样的实例，则创建一个。
     
      </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="mx.managers:IHistoryManagerClient"><apiName>IHistoryManagerClient</apiName><shortdesc>
  必须由已向历史记录管理器注册的对象实现的接口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
  必须由已向历史记录管理器注册的对象实现的接口。当保存和加载应用程序的历史记录状态时，HistoryManager 将调用此接口中的方法。
 
  <p>此接口由 Flex 导航器容器 TabNavigator、Accordion 和 ViewStack 实现。它必须由已向 HistoryManager 注册的任何其他组件实现。</p> 
 
  </apiDesc></apiClassifierDetail><related-links><link href="mx.managers.xml#HistoryManager"><linktext>mx.managers.HistoryManager</linktext></link></related-links><apiOperation id="mx.managers:IHistoryManagerClient:mx.managers:IHistoryManagerClient:loadState"><apiName>loadState</apiName><shortdesc>
	  加载此对象的状态。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>state</apiItemName><apiType value="Object"/><apiDesc>要加载的对象的状态。加载初始状态的应用程序时，此值为 null。
	 
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
	  加载此对象的状态。
	  
	  </apiDesc><example>以下代码将从已保存的状态中加载所选的索引和搜索字符串。
	  <pre>
	  public function loadState(state:Object):void
	  {
	  	// First, check to see if state is null. When the app is reset
	  	// back to its initial state, loadState() is passed null.
	  	if (state == null)
	  	{
	 		myList.selectedIndex = -1;
	  		mySearchInput.text = "";
	  	}
	  	else
	  	{
	  		myList.selectedIndex = state.selectedIndex;
	  		mySearchInput.text = state.searchString;
	  	}
	  }
	  </pre>
	  
	  </example></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IHistoryManagerClient:mx.managers:IHistoryManagerClient:saveState"><apiName>saveState</apiName><shortdesc>
	  保存此对象的状态。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>此对象的状态。
	  
	  </apiDesc><apiType value="Object"/></apiReturn></apiOperationDef><apiDesc>
	  保存此对象的状态。此对象包含每个属性的名称:值对，用于与状态一起保存。 
	 
	  <p>历史记录管理器将收集所有组件的状态信息，然后使用 URL 格式对这些信息进行编码。绝大多数浏览器对 URL 都有长度限制，因此返回的状态信息应尽可能短。</p>
	 
	  </apiDesc><example>以下代码将保存从 List 中选择的索引，以及一个搜索字符串。
	  <pre>
	  public function saveState():Object
	  {
	  	var state:Object = {};
	 
	  	state.selectedIndex = myList.selectedIndex;
	  	state.searchString = mySearchInput.text;
	 
	  	return state;
	 }
	 </pre>
	 
	  </example></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IHistoryManagerClient:mx.managers:IHistoryManagerClient:toString"><apiName>toString</apiName><shortdesc>
	  将此对象转换为唯一的字符串。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>此对象的唯一标识符。
	  
	  </apiDesc><apiType value="String"/></apiReturn></apiOperationDef><apiDesc>
	  将此对象转换为唯一的字符串。由 UIComponent 实现。
	 
	  </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="mx.managers:ISystemManager"><apiName>ISystemManager</apiName><shortdesc>
  一个 ISystemManager 管理一个“应用程序窗口”。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.events:IEventDispatcher</apiBaseInterface><apiBaseInterface>mx.core:IChildList</apiBaseInterface><apiBaseInterface>mx.core:IFlexModuleFactory</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
  一个 ISystemManager 管理一个“应用程序窗口”。桌面上或浏览器中运行的每个应用程序中都有一个区域用于显示应用程序的可视部分。该区域可能是操作系统中的某个窗口，也可能是浏览器中的某个区域。这是一个不同于 <codeph>mx.core.Application</codeph> 实例的“应用程序窗口”，该实例是应用程序中的“顶级”主窗口。
 
  <p>每个应用程序都有一个 ISystemManager。如果应用程序窗口的大小发生更改（您无法在应用程序中更改其大小，只能通过与操作系统窗口或浏览器交互来进行更改），则 ISystemManager 会发送一个事件。它是应用程序中所有可显示项目（例如 mx.core.Application 主实例以及所有弹出窗口、工具提示、光标等）的父项。任何以 ISystemManager 为父项的对象都将被视为“顶级”窗口，就连工具提示和光标也是如此。</p>
 
  <p>如果显示有多个 IFocusManagerContainer，并且用户正在与 IFocusManagerContainers 中的组件进行交互，则 ISystemManager 还可以在各顶级窗口之间切换焦点。</p>
 
  <p>所有未显式捕获的键盘和鼠标活动对 ISystemManager 都是可见的，因此，可以使用它来监视本应由您监视的活动。</p>
 
  <p>在将某个应用程序加载到另一个应用程序时，虽然仍会创建 ISystemManager，但是根据安全性和域规则，将不会使用它来管理“应用程序窗口”；而将作为加载它的 <codeph>Loader</codeph> 的 <codeph>content</codeph>，只是充当子应用程序的父级。</p>
 
  <p>ISystemManager 可维护多个子项列表，工具提示、光标、弹出窗口各有一个列表。因此，它可以确保弹出窗口“浮”在主应用程序窗口上方，工具提示“浮”在弹出窗口上方，光标“浮”在工具提示上方。若要对 ISystemManager 检查 <codeph>numChildren</codeph> 属性或 <codeph>getChildAt()</codeph> 方法，则需要访问主应用程序窗口以及其他任何没有弹出的窗口。要获得所有窗口（包括弹出窗口、工具提示和光标）的列表，请使用 <codeph>rawChildren</codeph> 属性。</p>
  
  </apiDesc></apiClassifierDetail><apiOperation id="mx.managers:ISystemManager:mx.managers:ISystemManager:deployMouseShields"><apiName>deployMouseShields</apiName><shortdesc>
      部署或删除鼠标盾。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>deploy</apiItemName><apiType value="Boolean"/><apiDesc><codeph>true</codeph> 将部署鼠标盾，<codeph>false</codeph> 将删除鼠标盾。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      部署或删除鼠标盾。鼠标盾可以阻止不受信任的应用程序获得鼠标输入。之所以需要阻止鼠标输入，是因为在不受信任的应用程序上拖动时，一般不会收到任何鼠标移动事件。出于安全考虑，Flash Player 在穿越受信任/不受信任的边界时不发送事件。通过用鼠标盾（假设您是其父级）遮盖不受信任的应用程序，可以得到鼠标移动消息，而拖动操作可以发挥预期的作用。 
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ISystemManager:mx.managers:ISystemManager:getDefinitionByName"><apiName>getDefinitionByName</apiName><shortdesc>
	  将给定的 String 转换为 Class 或数据包级的 Function。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>使用 <codeph>name</codeph> 或 null 表示的 Class。
	  
	  </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value="String"/><apiDesc>类名称，例如“mx.video.VideoManager”。
	 
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
	  将给定的 String 转换为 Class 或数据包级的 Function。根据是否加载到其他应用程序来调用适当的 <codeph>ApplicationDomain.getDefinition()</codeph> 方法。
	 
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ISystemManager:mx.managers:ISystemManager:getSandboxRoot"><apiName>getSandboxRoot</apiName><shortdesc>
      获取此 SecurityDomain 中所有顶级系统管理器的根系统管理器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>沙箱中最高等级的 systemManager
      
      </apiDesc><apiType value="flash.display:DisplayObject"/></apiReturn></apiOperationDef><apiDesc>
      获取此 SecurityDomain 中所有顶级系统管理器的根系统管理器。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ISystemManager:mx.managers:ISystemManager:getTopLevelRoot"><apiName>getTopLevelRoot</apiName><shortdesc>
      尝试获取位于主应用程序中的系统管理器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果安全限制允许，则为主应用程序的 systemManager；如果它位于不同的 SecurityDomain 中，则为 null。
      
      </apiDesc><apiType value="flash.display:DisplayObject"/></apiReturn></apiOperationDef><apiDesc>
      尝试获取位于主应用程序中的系统管理器。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ISystemManager:mx.managers:ISystemManager:getVisibleApplicationRect"><apiName>getVisibleApplicationRect</apiName><shortdesc>
      获取所加载的应用程序在屏幕上对用户可见的范围。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>包括此对象可见部分的 <codeph>Rectangle</codeph>。该矩形采用全局坐标。
      
      </apiDesc><apiType value="flash.geom:Rectangle"/></apiReturn><apiParam><apiItemName>bounds</apiItemName><apiType value="flash.geom:Rectangle"/><apiData>null</apiData><apiDesc>可选。可见矩形的起始边界。边界采用全局坐标。如果 <codeph>bounds</codeph> 为 null，则起始边界由系统管理器的 <codeph>screen</codeph> 属性定义。 
     
      </apiDesc></apiParam><apiParam><apiItemName>skipToSandboxRoot</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam></apiOperationDef><apiDesc>
      获取所加载的应用程序在屏幕上对用户可见的范围。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ISystemManager:mx.managers:ISystemManager:invalidateParentSizeAndDisplayList"><apiName>invalidateParentSizeAndDisplayList</apiName><shortdesc>
      尝试通知父 SWFLoader 应用程序的大小可能已更改。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiTool description="" name="Flex" version="4"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      尝试通知父 SWFLoader 应用程序的大小可能已更改。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ISystemManager:mx.managers:ISystemManager:isFontFaceEmbedded"><apiName>isFontFaceEmbedded</apiName><shortdesc>
      如果所需的字体已嵌入到此应用程序中，或已使用 Font.registerFont() 方法进行了全局注册，则返回 true。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果所需的字体已嵌入到此应用程序中，或已使用 <codeph>Font.registerFont()</codeph> 方法进行了全局注册，则返回 <codeph>true</codeph>。
      
      </apiDesc><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>tf</apiItemName><apiType value="flash.text:TextFormat"/><apiDesc>提供字符格式设置信息的 TextFormat 类。
	 
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
      如果所需的字体已嵌入到此应用程序中，或已使用 <codeph>Font.registerFont()</codeph> 方法进行了全局注册，则返回 <codeph>true</codeph>。
	 
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ISystemManager:mx.managers:ISystemManager:isTopLevelRoot"><apiName>isTopLevelRoot</apiName><shortdesc>
      测试此系统管理器是否为所有顶级系统管理器的根。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果此 SystemManager 是显示列表上所有 SystemManager 的根，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
      
      </apiDesc><apiType value="Boolean"/></apiReturn></apiOperationDef><apiDesc>
      测试此系统管理器是否为所有顶级系统管理器的根。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ISystemManager:mx.managers:ISystemManager:isTopLevel"><apiName>isTopLevel</apiName><shortdesc>
	  如果此 ISystemManager 负责应用程序窗口，则返回 true；如果此应用程序已加载到其他应用程序中，则返回 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果此 ISystemManager 负责应用程序窗口，则返回 <codeph>true</codeph>。
	  
	  </apiDesc><apiType value="Boolean"/></apiReturn></apiOperationDef><apiDesc>
	  如果此 ISystemManager 负责应用程序窗口，则返回 <codeph>true</codeph>；如果此应用程序已加载到其他应用程序中，则返回 <codeph>false</codeph>。
	 
	  </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:ISystemManager:mx.managers:ISystemManager:cursorChildren:get"><apiName>cursorChildren</apiName><shortdesc>
	  使用此 ISystemManager 作为父项的自定义光标的列表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>mx.core:IChildList</apiValueClassifier></apiValueDef><apiDesc>
	  使用此 ISystemManager 作为父项的自定义光标的列表。
	 
	  <p>ISystemManager 包含各种类型的子项，例如应用程序、弹出窗口、顶级窗口、工具提示和自定义光标。您可以通过 <codeph>cursorChildren</codeph> 属性访问自定义光标。</p>
	 
	  <p>IChildList 对象具有类似于 <codeph>getChildAt()</codeph> 的方法和类似于 <codeph>numChildren</codeph> 的属性。例如，<codeph>cursorChildren.numChildren</codeph> 可提供自定义光标数目（可以是 0，也可以是 1）；如果存在自定义光标，您可以将其当作 <codeph>cursorChildren.getChildAt(0)</codeph> 进行访问。</p>
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ISystemManager:mx.managers:ISystemManager:document:get"><apiName>document</apiName><shortdesc>
	  对文档对象的引用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Object"/></apiValueDef><apiDesc>
	  对文档对象的引用。文档对象是位于 Flex 应用程序、MXML 组件或 AS 组件层次结构顶层的 Object。
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ISystemManager:mx.managers:ISystemManager:focusPane:get"><apiName>focusPane</apiName><shortdesc>
	  在各组件之间共享的单个 Sprite，用作绘图焦点的叠加层。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="flash.display:Sprite"/></apiValueDef><apiDesc>
	  在各组件之间共享的单个 Sprite，用作绘图焦点的叠加层。如果您有具有焦点的子项组件，则可以共享它；如果您是 IFocusManagerComponent，则不能共享它。
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ISystemManager:mx.managers:ISystemManager:isProxy:get"><apiName>isProxy</apiName><shortdesc>
	  如果 ISystemManager 是代理而不是根类，则为 true。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
	  如果 ISystemManager 是代理而不是根类，则为 true。
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ISystemManager:mx.managers:ISystemManager:loaderInfo:get"><apiName>loaderInfo</apiName><shortdesc>
	  提供应用程序相关信息的 LoaderInfo 对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="flash.display:LoaderInfo"/></apiValueDef><apiDesc>
	  提供应用程序相关信息的 LoaderInfo 对象。
     
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ISystemManager:mx.managers:ISystemManager:numModalWindows:get"><apiName>numModalWindows</apiName><shortdesc>
      模式窗口的数量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="int"/></apiValueDef><apiDesc>
      模式窗口的数量。  
     
      <p>模式窗口不允许在其他窗口中单击，因为这通常会激活该窗口中的 FocusManager。PopUpManager 在创建和破坏模式窗口时会修改此计数。</p>
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ISystemManager:mx.managers:ISystemManager:popUpChildren:get"><apiName>popUpChildren</apiName><shortdesc>
	  将使用此 ISystemManager 作为父项的最顶级窗口（弹出窗口）的列表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>mx.core:IChildList</apiValueClassifier></apiValueDef><apiDesc>
	  将使用此 ISystemManager 作为父项的最顶级窗口（弹出窗口）的列表。
	 
	  <p>ISystemManager 包含各种类型的子项，例如应用程序、弹出窗口、工具提示和自定义光标。您可以通过 <codeph>popUpChildren</codeph> 属性访问最顶级窗口。</p>
	 
	  <p>IChildList 对象具有类似于 <codeph>getChildAt()</codeph> 的方法和类似于 <codeph>numChildren</codeph> 的属性。例如，<codeph>popUpChildren.numChildren</codeph> 可提供最顶部窗口的数量，您可将最顶部窗口当作 <codeph>popUpChildren.getChildAt(i)</codeph> 进行访问。</p>
	 
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ISystemManager:mx.managers:ISystemManager:rawChildren:get"><apiName>rawChildren</apiName><shortdesc>
	  使用此 ISystemManager 作为父项的所有子项的列表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>mx.core:IChildList</apiValueClassifier></apiValueDef><apiDesc>
	  使用此 ISystemManager 作为父项的所有子项的列表。
	 
	  <p>ISystemManager 包含各种类型的子项，例如应用程序、弹出窗口、工具提示和自定义光标。</p>
	 
	  <p>IChildList 对象具有类似于 <codeph>getChildAt()</codeph> 的方法和类似于 <codeph>numChildren</codeph> 的属性。</p>
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ISystemManager:mx.managers:ISystemManager:screen:get"><apiName>screen</apiName><shortdesc>
	  应用程序窗口的大小和位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="flash.geom:Rectangle"/></apiValueDef><apiDesc>
	  应用程序窗口的大小和位置。Rectangle 对象包含 <codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph> 属性。矩形位于沙箱根坐标中。
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ISystemManager:mx.managers:ISystemManager:stage:get"><apiName>stage</apiName><shortdesc>
	  代表映射到此 SystemManager 中的应用程序窗口的 flash.display.Stage。
	  
	  </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="flash.display:Stage"/></apiValueDef><apiDesc>
	  代表映射到此 SystemManager 中的应用程序窗口的 flash.display.Stage。
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ISystemManager:mx.managers:ISystemManager:toolTipChildren:get"><apiName>toolTipChildren</apiName><shortdesc>
	  将使用此 ISystemManager 作为父项的工具提示的列表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>mx.core:IChildList</apiValueClassifier></apiValueDef><apiDesc>
	  将使用此 ISystemManager 作为父项的工具提示的列表。
	 
	  <p>ISystemManager 包含各种类型的子项，例如应用程序、弹出窗口、最顶部窗口、工具提示和自定义光标。</p>
	 
	  <p>IChildList 对象具有类似于 <codeph>getChildAt()</codeph> 的方法和类似于 <codeph>numChildren</codeph> 的属性。例如，<codeph>toolTipChildren.numChildren</codeph> 可提供工具提示数目（可以是 0，也可以是 1）；如果存在工具提示，您可以将其当作 <codeph>toolTipChildren.getChildAt(0)</codeph> 进行访问。</p>
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ISystemManager:mx.managers:ISystemManager:topLevelSystemManager:get"><apiName>topLevelSystemManager</apiName><shortdesc>
	  负责应用程序窗口的 ISystemManager。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>mx.managers:ISystemManager</apiValueClassifier></apiValueDef><apiDesc>
	  负责应用程序窗口的 ISystemManager。只要此应用程序尚未加载到其它应用程序中，这就是同一个 ISystemManager。
	  
	  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:ToolTipManager"><apiName>ToolTipManager</apiName><shortdesc>
  通过 ToolTipManager，您可以设置基本的工具提示和错误提示功能，如显示延迟和禁用的工具提示。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
  通过 ToolTipManager，您可以设置基本的工具提示和错误提示功能，如显示延迟和禁用的工具提示。
 
  </apiDesc></apiClassifierDetail><related-links><link href="mx.controls.xml#ToolTip"><linktext>mx.controls.ToolTip</linktext></link><link href="mx.validators.xml#Validator"><linktext>mx.validators.Validator</linktext></link></related-links><apiOperation id="mx.managers:ToolTipManager:createToolTip"><apiName>createToolTip</apiName><shortdesc>
      使用指定的文本创建 ToolTip 类的实例，然后在舞台坐标中的指定位置显示此实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>新创建的 ToolTip。
     
      
      </apiDesc><apiOperationClassifier>mx.core:IToolTip</apiOperationClassifier></apiReturn><apiParam><apiItemName>text</apiItemName><apiType value="String"/><apiDesc>要在 ToolTip 实例中显示的文本。
     
      </apiDesc></apiParam><apiParam><apiItemName>x</apiItemName><apiType value="Number"/><apiDesc>ToolTip 在舞台坐标中的水平坐标。如果存在多个舞台，则根据 <codeph>context</codeph> 参数确定相关的舞台。
     
      </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiType value="Number"/><apiDesc>ToolTip 在舞台坐标中的垂直坐标。如果存在多个舞台，则根据 <codeph>context</codeph> 参数确定相关的舞台。
     
      </apiDesc></apiParam><apiParam><apiItemName>errorTipBorderStyle</apiItemName><apiType value="String"/><apiData>null</apiData><apiDesc>错误提示的边框样式。此方法参数可以是 null、“errorTipRight”、“errorTipAbove”或“errorTipBelow”。如果为 null，则 <codeph>createToolTip()</codeph> 方法将创建一个普通的 ToolTip。如果为“errorTipRight”、“errorTipAbove”或“errorTipBelow”，则 <codeph>createToolTip()</codeph> 方法将创建一个错误提示，而此参数将确定错误提示箭头的指向（错误的目标）。例如，如果传递“errorTipRight”，则 Flex 会将错误提示（通过 x 参数和 y 参数）放在错误目标的右侧；箭头位于错误提示的左边缘处。
     
      </apiDesc></apiParam><apiParam><apiItemName>context</apiItemName><apiOperationClassifier>mx.core:IUIComponent</apiOperationClassifier><apiData>null</apiData><apiDesc>确定使用的 StyleManager。通常，您传递 ToolTip 显示时所在的对象，以便 ToolTip 的 StyleManager 与该对象所使用的 StyleManager 相同。 
     
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      使用指定的文本创建 ToolTip 类的实例，然后在舞台坐标中的指定位置显示此实例。
     
      <p>ToolTip 在各自层中显示时，位于光标之下、其他所有对象之上。</p>
     
      <p>使用 ToolTip 的标准方式是，允许 ToolTipManager 在用户将鼠标移动到设置了 <codeph>toolTip</codeph> 属性的对象上方时自动显示和隐藏工具提示。通过将 ToolTipManager 的 <codeph>enabled</codeph> 属性设为 <codeph>false</codeph>，可以关闭此 ToolTip 自动管理功能。</p>
     
      <p>与此相反，将此方法与 <codeph>destroyToolTip()</codeph> 配合使用可以以编程方式控制 ToolTip。您可以在选择的时间和位置显示工具提示，如果需要，甚至还可以同时显示多个工具提示。（ToolTipManager 绝不执行此操作，因为这样通常会使用户感到迷惑。）</p>
     
      <p>此方法首先会为创建一个新的 ToolTip 实例，然后调用 <codeph>addChild()</codeph> 方法将此实例放到 SystemManager 的工具提示层。如果出现错误提示，它会设置正确的样式。接着，它设置 ToolTip 的文本，根据文本大小调整 ToolTip 的大小，并将其放在指定的位置。</p>
     
      <p>必须保存此方法返回的对 ToolTip 的引用，以便将其传递给 <codeph>destroyToolTip()</codeph> 方法。</p>
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ToolTipManager:destroyToolTip"><apiName>destroyToolTip</apiName><shortdesc>
      破坏由 createToolTip() 方法创建的指定 ToolTip。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>toolTip</apiItemName><apiOperationClassifier>mx.core:IToolTip</apiOperationClassifier><apiDesc>要破坏的 ToolTip 实例。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      破坏由 <codeph>createToolTip()</codeph> 方法创建的指定 ToolTip。
     
      <p>此方法可以调用 <codeph>removeChild()</codeph> 方法，以从 SystemManager 的 ToolTip 层中删除指定的工具提示。如果不保留对 ToolTip 的引用，随后就会将其作为垃圾进行回收。</p>
     
      <p>您不应该对 ToolTipManager 的 <codeph>currentToolTip</codeph> 调用此方法。</p>
     
      </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:ToolTipManager:currentTarget:get"><apiName>currentTarget</apiName><shortdesc>
      当前显示工具提示的 UIComponent；如果未显示工具提示，则为 null。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiType value="flash.display:DisplayObject"/></apiValueDef><apiDesc>
      当前显示工具提示的 UIComponent；如果未显示工具提示，则为 <codeph>null</codeph>。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ToolTipManager:currentToolTip:get"><apiName>currentToolTip</apiName><shortdesc>
      当前可见的 ToolTip 对象；如果未显示 ToolTip 对象，则为 null。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>mx.core:IToolTip</apiValueClassifier></apiValueDef><apiDesc>
      当前可见的 ToolTip 对象；如果未显示 ToolTip 对象，则为 <codeph>null</codeph>。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ToolTipManager:enabled:get"><apiName>enabled</apiName><shortdesc>
      如果为 true，则当用户将鼠标指针移至组件上方时，ToolTipManager 会自动显示工具提示。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/><apiDefaultValue>true
      
      </apiDefaultValue></apiValueDef><apiDesc>
      如果为 <codeph>true</codeph>，则当用户将鼠标指针移至组件上方时，ToolTipManager 会自动显示工具提示。如果为 <codeph>false</codeph>，则不会显示任何工具提示。
     
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ToolTipManager:hideDelay:get"><apiName>hideDelay</apiName><shortdesc>
      自工具提示出现时起，Flex 要隐藏此提示前所需等待的时间量（以毫秒为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiType value="Number"/><apiDefaultValue>10000
      
      </apiDefaultValue></apiValueDef><apiDesc>
      自工具提示出现时起，Flex 要隐藏此提示前所需等待的时间量（以毫秒为单位）。Flex 隐藏某一工具提示后，用户必须将鼠标从该组件移开后再移回才能重新看到此工具提示。如果将 <codeph>hideDelay</codeph> 设为 <codeph>Infinity</codeph>，则只有在用户触发某个事件（如将鼠标从该组件移开）时，Flex 才会隐藏该工具提示。
     
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ToolTipManager:hideEffect:get"><apiName>hideEffect</apiName><shortdesc>
      隐藏工具提示时播放的效果；如果工具提示在消失时不应显示任何效果，则为 null。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>mx.effects:IAbstractEffect</apiValueClassifier><apiDefaultValue>null
      
      </apiDefaultValue></apiValueDef><apiDesc>
      隐藏工具提示时播放的效果；如果工具提示在消失时不应显示任何效果，则为 <codeph>null</codeph>。
     
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ToolTipManager:scrubDelay:get"><apiName>scrubDelay</apiName><shortdesc>
      在 Flex 再次等待 showDelay 持续显示工具提示之前，用户在各控件间移动鼠标时可以花费的时间（以毫秒为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiType value="Number"/><apiDefaultValue>100
      
      </apiDefaultValue></apiValueDef><apiDesc>
      在 Flex 再次等待 <codeph>showDelay</codeph> 持续显示工具提示之前，用户在各控件间移动鼠标时可以花费的时间（以毫秒为单位）。
     
      <p>当用户在各控件间快速移动鼠标时，此设置将非常有用；在第一个工具提示显示完毕后，Flex 将立即显示其他工具提示，而不会等待。<codeph>scrubDelay</codeph> 中设置的时间越短，用户越有可能必须等够 <codeph>showDelay</codeph> 中指定的时间才能看到下一个工具提示。当一个工具栏中有多个按钮，并且用户需要快速在这些按钮之间进行扫描以查看各个按钮的功能简述时，此属性非常适用。</p>
     
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ToolTipManager:showDelay:get"><apiName>showDelay</apiName><shortdesc>
      当用户将鼠标移至具有工具提示的组件上方时，Flex 等待 ToolTip 框出现所需的时间（以毫秒为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiType value="Number"/><apiDefaultValue>500
      
      </apiDefaultValue></apiValueDef><apiDesc>
      当用户将鼠标移至具有工具提示的组件上方时，Flex 等待 ToolTip 框出现所需的时间（以毫秒为单位）。若要立即显示 ToolTip 框，请将 <codeph>showDelay</codeph> 设为 0。
     
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ToolTipManager:showEffect:get"><apiName>showEffect</apiName><shortdesc>
      显示工具提示时播放的效果；如果工具提示在显示时不应显示任何效果，则为 null。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiValueClassifier>mx.effects:IAbstractEffect</apiValueClassifier><apiDefaultValue>null
      
      </apiDefaultValue></apiValueDef><apiDesc>
      显示工具提示时播放的效果；如果工具提示在显示时不应显示任何效果，则为 <codeph>null</codeph>。
     
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ToolTipManager:toolTipClass:get"><apiName>toolTipClass</apiName><shortdesc>
      创建工具提示要用到的类。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiType value="Class"/><apiDefaultValue>mx.controls.ToolTip
      
      </apiDefaultValue></apiValueDef><apiDesc>
      创建工具提示要用到的类。
      
      </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:CursorManagerPriority"><apiName>CursorManagerPriority</apiName><shortdesc>
  CursorManagerPriority 类定义 CursorManager.setCursor() 方法的 priority 参数的常数值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiFinal/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
  CursorManagerPriority 类定义 <codeph>CursorManager.setCursor()</codeph> 方法的 <codeph>priority</codeph> 参数的常量值。 
 
  </apiDesc></apiClassifierDetail><related-links><link href="mx.managers.xml#CursorManager"><linktext>mx.managers.CursorManager</linktext></link></related-links><apiValue id="mx.managers:CursorManagerPriority:HIGH"><apiName>HIGH</apiName><shortdesc>
	  一个常量，当作为 priority 参数传递给 setCursor() 时，用于指定光标的最高优先级。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiType value="int"/></apiValueDef><apiDesc>
	  一个常量，当作为 <codeph>priority</codeph> 参数传递给 <codeph>setCursor()</codeph> 时，用于指定光标的最高优先级。
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:CursorManagerPriority:LOW"><apiName>LOW</apiName><shortdesc>
	  一个常量，当作为 priority 参数传递给 setCursor() 时，用于指定光标的最低优先级。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>3</apiData><apiType value="int"/></apiValueDef><apiDesc>
	  一个常量，当作为 <codeph>priority</codeph> 参数传递给 <codeph>setCursor()</codeph> 时，用于指定光标的最低优先级。
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:CursorManagerPriority:MEDIUM"><apiName>MEDIUM</apiName><shortdesc>
	  一个常量，当作为 priority 参数传递给 setCursor() 时，用于指定光标的中级优先级。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiType value="int"/></apiValueDef><apiDesc>
	  一个常数，当作为 <codeph>priority</codeph> 参数传递给 <codeph>setCursor()</codeph> 时，用于指定光标的中级优先级。
	  
	  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:DragManager"><apiName>DragManager</apiName><shortdesc>
  DragManager 类管理拖放操作，您可以使用它来将数据从 Flex 应用程序中的一个位置移动到另一位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion><styles><style inherit="no" name="rejectCursor" owner="mx.managers:DragManager" playerVersion="Flash9" type="Class">
<description>
  针对拒绝操作所显示的光标。默认值为 Assets.swf 文件中的“mx.skins.cursor.DragReject”元件。
  
  </description>

<playerversion>AIR 1.1
  </playerversion>
	<prolog><asCustoms><langversion>3.0
  </langversion><productversion>Flex 3
 </productversion></asCustoms></prolog></style><style inherit="no" name="moveCursor" owner="mx.managers:DragManager" playerVersion="Flash9" type="Class">
<description>
  移动操作期间显示的光标。默认值为 Assets.swf 文件中的“mx.skins.cursor.DragMove”元件。
  
  </description>

<playerversion>AIR 1.1
  </playerversion>
	<prolog><asCustoms><langversion>3.0
  </langversion><productversion>Flex 3
 </productversion></asCustoms></prolog></style><style inherit="no" name="linkCursor" owner="mx.managers:DragManager" playerVersion="Flash9" type="Class">
<description>
  链接操作期间显示的光标。默认值为 Assets.swf 文件中的“mx.skins.cursor.DragLink”元件。
  
  </description>

<playerversion>AIR 1.1
  </playerversion>
	<prolog><asCustoms><langversion>3.0
  </langversion><productversion>Flex 3
 </productversion></asCustoms></prolog></style><style inherit="no" name="defaultDragImageSkin" owner="mx.managers:DragManager" playerVersion="Flash9" type="Class">
<description>
  绘制默认拖动图像（也称为拖动代理）所用的外观。
 
  </description>
<default>mx.skins.halo.DefaultDragImage (for both Halo and Spark themes)
  
  </default>

<playerversion>AIR 1.1
  </playerversion>
	<prolog><asCustoms><langversion>3.0
  </langversion><productversion>Flex 3
 </productversion></asCustoms></prolog></style><style inherit="no" name="copyCursor" owner="mx.managers:DragManager" playerVersion="Flash9" type="Class">
<description>
  复制操作期间显示的光标。默认值为 Assets.swf 文件中的“mx.skins.cursor.DragCopy”元件。
  
  </description>

<playerversion>AIR 1.1
  </playerversion>
	<prolog><asCustoms><langversion>3.0
  </langversion><productversion>Flex 3
 </productversion></asCustoms></prolog></style></styles></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
  DragManager 类管理拖放操作，您可以使用它来将数据从 Flex 应用程序中的一个位置移动到另一位置。例如，您可以选择一个对象（如 List 控件中的项目）或一个 Flex 控件（如 Image 控件），然后将其拖至另一个组件进行添加。
  
  <p>DragManager 的所有方法和属性都是静态的，因此不需要为其创建实例。</p>
  
  <p>所有 Flex 组件都支持拖放操作。Flex 为 List、Tree 和 DataGrid 控件的拖放操作提供了附加支持。</p>
  
  <p>当用户使用鼠标选择某个项目时，所选组件称为拖动启动器。拖动操作期间显示的图像称为拖动代理。</p>
  
  <p>当用户将拖动代理移动到其他组件时，系统会向该组件发送 <codeph>dragEnter</codeph> 事件。如果该组件接受拖动，即可成为放置目标，并接收 <codeph>dragOver</codeph>、<codeph>dragExit</codeph> 和 <codeph>dragDrop</codeph> 事件。</p>
  
  <p>拖动操作完成后，会向拖动启动器发送 <codeph>dragComplete</codeph> 事件。</p>
  
  </apiDesc></apiClassifierDetail><related-links><link href="mx.core.xml#DragSource"><linktext>mx.core.DragSource</linktext></link><link href="mx.events.xml#DragEvent"><linktext>mx.events.DragEvent</linktext></link><link href="mx.core.xml#UIComponent"><linktext>mx.core.UIComponent</linktext></link></related-links><apiOperation id="mx.managers:DragManager:acceptDragDrop"><apiName>acceptDragDrop</apiName><shortdesc>
      如果接受拖/放数据，将从 dragEnter 事件处理函数调用此方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>mx.core:IUIComponent</apiOperationClassifier><apiDesc>接受拖动的放置目标。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      如果接受拖/放数据，将从 <codeph>dragEnter</codeph> 事件处理函数调用此方法。通常，您将 <codeph>event.target</codeph> 强制类型转换为放置目标的数据类型。在以下示例中，放置目标为 MX Canvas 容器： 
     
      <pre>DragManager.acceptDragDrop(Canvas(event.target));</pre>
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:DragManager:doDrag"><apiName>doDrag</apiName><shortdesc>
      启动拖放操作。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>dragInitiator</apiItemName><apiOperationClassifier>mx.core:IUIComponent</apiOperationClassifier><apiDesc>指定启动拖动的组件的 IUIComponent。
     
      </apiDesc></apiParam><apiParam><apiItemName>dragSource</apiItemName><apiOperationClassifier>mx.core:DragSource</apiOperationClassifier><apiDesc>包含正在拖动的数据的 DragSource 对象。
     
      </apiDesc></apiParam><apiParam><apiItemName>mouseEvent</apiItemName><apiType value="flash.events:MouseEvent"/><apiDesc>包含与启动拖动相关的鼠标信息的 MouseEvent。
     
      </apiDesc></apiParam><apiParam><apiItemName>dragImage</apiItemName><apiOperationClassifier>mx.core:IFlexDisplayObject</apiOperationClassifier><apiData>null</apiData><apiDesc>要拖动的图像。此参数是可选的。如果省略此参数，则在拖放操作期间将使用标准的拖动矩形。如果指定了某个图像，则必须显式设置该图像的高度和宽度，否则此图像将不显示。
     
      </apiDesc></apiParam><apiParam><apiItemName>xOffset</apiItemName><apiType value="Number"/><apiData>0</apiData><apiDesc>用于指定 <codeph>dragImage</codeph> 的 x 偏移（以像素为单位）的数字。此参数是可选的。如果省略此参数，将在拖动启动器的左上角显示拖动代理。该偏移是指从拖动代理的左边缘到拖动启动器的左边缘的距离（以像素为单位），通常为负数。
     
      </apiDesc></apiParam><apiParam><apiItemName>yOffset</apiItemName><apiType value="Number"/><apiData>0</apiData><apiDesc>用于指定 <codeph>dragImage</codeph> 的 y 偏移（以像素为单位）的数字。此参数是可选的。如果省略此参数，将在拖动启动器的左上角显示拖动代理。该偏移是指从拖动代理的上边缘到拖动启动器的上边缘的距离（以像素为单位），通常为负数。
     
      </apiDesc></apiParam><apiParam><apiItemName>imageAlpha</apiItemName><apiType value="Number"/><apiData>0.5</apiData><apiDesc>用于指定拖动图像所用的 Alpha 值的数字。此参数是可选的。如果省略此参数，则默认的 Alpha 值为 0.5。值为 0.0 表示图像是透明的；值为 1.0 表示图像完全不透明。 
         
          </apiDesc></apiParam><apiParam><apiItemName>allowMove</apiItemName><apiType value="Boolean"/><apiData>true</apiData><apiDesc>指示是否允许放置目标移动所拖动的数据。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      启动拖放操作。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:DragManager:getFeedback"><apiName>getFeedback</apiName><shortdesc>
      返回当前的拖放反馈。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>可能的返回值有：<codeph>DragManager.COPY</codeph>、<codeph>DragManager.MOVE</codeph>、<codeph>DragManager.LINK</codeph> 或 <codeph>DragManager.NONE</codeph>。
      
      </apiDesc><apiType value="String"/></apiReturn></apiOperationDef><apiDesc>
      返回当前的拖放反馈。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:DragManager:showFeedback"><apiName>showFeedback</apiName><shortdesc>
      设置拖放操作的反馈指示符。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>feedback</apiItemName><apiType value="String"/><apiDesc>要显示的反馈指示符类型。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      设置拖放操作的反馈指示符。可能的值有：<codeph>DragManager.COPY</codeph>、<codeph>DragManager.MOVE</codeph>、<codeph>DragManager.LINK</codeph> 或 <codeph>DragManager.NONE</codeph>。
     
      </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:DragManager:COPY"><apiName>COPY</apiName><shortdesc>
      用于指定拖动动作的类型是“copy”的常量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>copy</apiData><apiType value="String"/></apiValueDef><apiDesc>
      用于指定拖动动作的类型是“copy”的常量。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:DragManager:LINK"><apiName>LINK</apiName><shortdesc>
      用于指定拖动动作的类型是“link”的常量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>link</apiData><apiType value="String"/></apiValueDef><apiDesc>
      用于指定拖动动作的类型是“link”的常量。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:DragManager:MOVE"><apiName>MOVE</apiName><shortdesc>
      用于指定拖动动作的类型是“move”的常量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>move</apiData><apiType value="String"/></apiValueDef><apiDesc>
      用于指定拖动动作的类型是“move”的常量。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:DragManager:NONE"><apiName>NONE</apiName><shortdesc>
      用于指定拖动动作的类型是“none”的常量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>none</apiData><apiType value="String"/></apiValueDef><apiDesc>
      用于指定拖动动作的类型是“none”的常量。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:DragManager:isDragging:get"><apiName>isDragging</apiName><shortdesc>
      一个只读属性，如果拖动操作正在进行，则返回 true。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
      一个只读属性，如果拖动操作正在进行，则返回 <codeph>true</codeph>。
      
      </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:IFocusManagerContainer"><apiName>IFocusManagerContainer</apiName><shortdesc>
  IFocusManagerContainer 接口可定义一类接口，容器实现此类接口才能承载 FocusManager。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.events:IEventDispatcher</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
  IFocusManagerContainer 接口可定义一类接口，容器实现此类接口才能承载 FocusManager。PopUpManager 可在其弹出的任何 IFocusManagerContainer 中自动安装 FocusManager。
  
  </apiDesc></apiClassifierDetail><apiOperation id="mx.managers:IFocusManagerContainer:mx.managers:IFocusManagerContainer:contains"><apiName>contains</apiName><shortdesc>
      确定指定的显示对象是否为容器实例的子项或该实例本身。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果子对象是容器的子项或容器本身，则返回 <codeph>true</codeph>；否则，返回 <codeph>false</codeph>。
      
      </apiDesc><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>child</apiItemName><apiType value="flash.display:DisplayObject"/><apiDesc>要测试的子对象。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      确定指定的显示对象是否为容器实例的子项或该实例本身。搜索目标包括整个显示列表，其中包括此容器实例。孙项、曾孙项等，每项都返回 <codeph>true</codeph>。
     
      </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:IFocusManagerContainer:mx.managers:IFocusManagerContainer:defaultButton:get"><apiName>defaultButton</apiName><shortdesc>
      指定为容器的默认按钮的 Button 控件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>mx.core:IFlexDisplayObject</apiValueClassifier><apiDefaultValue>null
     </apiDefaultValue></apiValueDef><apiDesc>
      指定为容器的默认按钮的 Button 控件。当容器中的控件具有焦点时，按 Enter 键与单击此 Button 控件的效果相同。
     
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:IFocusManagerContainer:mx.managers:IFocusManagerContainer:focusManager:get"><apiName>focusManager</apiName><shortdesc>
      此组件的 FocusManager。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>mx.managers:IFocusManager</apiValueClassifier></apiValueDef><apiDesc>
      此组件的 FocusManager。FocusManager 必须位于 <codeph>focusManager</codeph> 属性中。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:IFocusManagerContainer:mx.managers:IFocusManagerContainer:systemManager:get"><apiName>systemManager</apiName><shortdesc conref="mx.core.UIComponent#systemManager">
      </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>mx.managers:ISystemManager</apiValueClassifier></apiValueDef><apiDesc conref="mx.core.UIComponent#systemManager">
      </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:ILayoutManager"><apiName>ILayoutManager</apiName><shortdesc>
  LayoutManager 是 Flex 的度量和布局策略所基于的引擎。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.events:IEventDispatcher</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
  LayoutManager 是 Flex 的度量和布局策略所基于的引擎。布局分三个阶段执行：提交、度量和布局。
 
  <p>这三个阶段互不相同，并且，只有在处理完当前阶段的所有 UIComponent 之后才会进入下一阶段。在某个阶段中处理 UIComponent 期间，可能出现另一阶段请求重新处理 UIComponent 的情况。这些请求将进行排队，并且只在下次运行此阶段时才得到处理。</p>
 
  <p><b>提交</b>阶段从调用 <codeph>validateProperties()</codeph> 开始，该方法将遍历一个对象列表（该列表按嵌套级别反向排序），并调用每个对象的 <xref href="../core/UIComponent.html#validateProperties()"><codeph>validateProperties()</codeph></xref> 方法。</p>
 
  <p>列表中的对象是按与嵌套级别正相反的顺序接受处理的，所以最先访问的是嵌套深度<b>最浅</b>的对象。这也可以称为自上而下或从外到内的顺序。</p>
 
  <p>在此阶段中，允许内容依据属性设置而定的组件在进入度量和布局阶段之前进行自我配置。为了获得更好的性能，组件的属性 setter 方法有时不执行更新到新属性值所需的全部操作。但是，属性 setter 会调用 <codeph>invalidateProperties()</codeph> 方法，并在运行此阶段之前延迟此操作。这样，可以在多次设置属性时避免执行不必要的操作。</p>
 
  <p><b>度量</b>阶段从调用 <codeph>validateSize()</codeph> 开始，该方法将遍历一个对象列表（该列表按嵌套级别排序），并调用每个对象的 <xref href="../core/UIComponent.html#validateSize()"><codeph>validateSize()</codeph></xref> 方法，以确定对象大小是否已更改。</p>
 
  <p>如果之前调用过对象的 <xref href="../core/UIComponent.html#invalidateSize()"> <codeph>invalidateSize()</codeph></xref> 方法，则调用 <codeph>validateSize()</codeph> 方法。如果对象的大小或位置因调用 <codeph>validateSize()</codeph> 而发生了更改，则会调用对象的 <xref href="../core/UIComponent.html#invalidateDisplayList()"> <codeph>invalidateDisplayList()</codeph></xref> 方法，这就会将该对象添加到处理队列中，等待下次运行布局阶段时进行处理。此外，已分别调用 <xref href="../core/UIComponent.html#invalidateSize()"> <codeph>invalidateSize()</codeph></xref> 和 <xref href="../core/UIComponent.html#invalidateDisplayList()"> <codeph>invalidateDisplayList()</codeph></xref> 为度量和布局这两个阶段标记了对象的父项。</p>
 
  <p>列表中的对象是按嵌套级别的顺序进行处理的，所以最先访问的是嵌套深度<b>最深</b>的对象。这也可以称为自下而上或从内到外的顺序。</p>
 
  <p><b>布局</b>阶段从调用 <codeph>validateDisplayList()</codeph> 方法开始，该方法将遍历一个对象列表（该列表按嵌套级别反向排序），并调用每个对象的 <xref href="../core/UIComponent.html#validateDisplayList()"><codeph>validateDisplayList()</codeph></xref> 方法，以请求对象确定它所包含的所有组件（即其子对象）的大小和位置。</p>
 
  <p>	如果之前调用过对象的 <xref href="../core/UIComponent.html#invalidateDisplayList()"> <codeph>invalidateDisplayList()</codeph></xref> 方法，则调用 <codeph>validateDisplayList()</codeph> 方法。</p>
 
  <p>列表中的对象是按与嵌套级别正相反的顺序接受处理的，所以最先访问的是嵌套深度<b>最浅</b>的对象。这也可以称为自上而下或从外到内的顺序。</p>
 
  <p>通常情况下，组件不会覆盖 <codeph>validateProperties()</codeph>、<codeph>validateSize()</codeph> 或 <codeph>validateDisplayList()</codeph> 方法。对于 UIComponent 而言，大部分组件都会覆盖分别由 <codeph>validateProperties()</codeph>、<codeph>validateSize()</codeph> 或 <codeph>validateDisplayList()</codeph> 方法调用的 <codeph>commitProperties()</codeph>、<codeph>measure()</codeph> 或 <codeph>updateDisplayList()</codeph> 方法。</p>
 
  <p>当应用程序启动时，将创建一个 LayoutManager 实例并将其存储在 <codeph>UIComponent.layoutManager</codeph> 属性中。所有组件都应使用此实例。如果您无权访问 UIComponent 对象，也可以使用静态 <codeph>LayoutManager.getInstance()</codeph> 方法访问 LayoutManager。</p>
  
  </apiDesc></apiClassifierDetail><apiOperation id="mx.managers:ILayoutManager:mx.managers:ILayoutManager:invalidateDisplayList"><apiName>invalidateDisplayList</apiName><shortdesc>
	  当组件发生的更改导致其布局和/或视觉效果需要更改时调用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>mx.managers:ILayoutManagerClient</apiOperationClassifier><apiDesc>更改过的对象。
	  
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
	  当组件发生的更改导致其布局和/或视觉效果需要更改时调用。在这种情况下，即使没有更改过组件的大小，也必须运行组件的布局算法。例如，当添加了新的子组件时、样式属性发生更改时或组件的父项为组件赋予了新尺寸时。
	 
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ILayoutManager:mx.managers:ILayoutManager:invalidateProperties"><apiName>invalidateProperties</apiName><shortdesc>
	  向希望调用其 validateProperties() 方法的组件的列表中添加一个对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>mx.managers:ILayoutManagerClient</apiOperationClassifier><apiDesc>属性已发生更改的对象。
	  
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
	  向希望调用其 <codeph>validateProperties()</codeph> 方法的组件的列表中添加一个对象。组件应在属性发生更改时调用此方法。通常，属性 setter 方法将新值存储在临时变量中，然后调用 <codeph>invalidateProperties()</codeph> 方法，以便稍后在新值实际应用到组件和/或其子项时调用其 <codeph>validateProperties()</codeph> 和 <codeph>commitProperties()</codeph> 方法。此策略非常适用于以下经常遇到的情况：一次更改多个属性，并且这些属性之间可能会交互；在应用代码时需重复某些代码或需要按一定顺序应用代码。此策略可以为应用新属性值提供最有效的方法。
	 
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ILayoutManager:mx.managers:ILayoutManager:invalidateSize"><apiName>invalidateSize</apiName><shortdesc>
	  向希望调用其 validateSize() 方法的组件的列表中添加一个对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>mx.managers:ILayoutManagerClient</apiOperationClassifier><apiDesc>大小已发生更改的对象。
	  
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
	  向希望调用其 <codeph>validateSize()</codeph> 方法的组件的列表中添加一个对象。当对象的大小发生更改时调用。
	 
	  <p>导致对象大小发生更改的原因有两个：</p>
	 
	  <ol>
	    <li>对象的内容发生更改。例如，在更改按钮的 <codeph>label</codeph> 时更改了此按钮的大小。</li>
	    <li>脚本可显式更改下列属性之一：<codeph>minWidth</codeph>、<codeph>minHeight</codeph>、<codeph>explicitWidth</codeph>、<codeph>explicitHeight</codeph>、<codeph>maxWidth</codeph> 或 <codeph>maxHeight</codeph>。</li>
	  </ol>
	 
	  <p>发生第一种情况时，必须重新计算对象的测量值。发生第二种情况时，则不必重新计算测量值，因为对象的新尺寸是已知的。但是，必须重新测量和重新布局对象的父项。</p>
	 
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ILayoutManager:mx.managers:ILayoutManager:isInvalid"><apiName>isInvalid</apiName><shortdesc>
	  如果存在需要验证的组件，则返回 true；如果已经验证所有组件，则返回 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果存在需要验证的组件，则返回 <codeph>true</codeph>；如果已经验证所有组件，则返回 <codeph>false</codeph>。
	  
	  </apiDesc><apiType value="Boolean"/></apiReturn></apiOperationDef><apiDesc>
	  如果存在需要验证的组件，则返回 <codeph>true</codeph>；如果已经验证所有组件，则返回 <codeph>false</codeph>。
          
         </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ILayoutManager:mx.managers:ILayoutManager:validateClient"><apiName>validateClient</apiName><shortdesc>
	  当属性发生更改后，组件通常不会立即应用这些更改，</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>mx.managers:ILayoutManagerClient</apiOperationClassifier><apiDesc>传入的组件用于测试应该验证哪些组件。将调用此组件中包含的所有组件的 <codeph>validateProperties()</codeph>、<codeph>commitProperties()</codeph>、<codeph>validateSize()</codeph>、<codeph>measure()</codeph>、<codeph>validateDisplayList()</codeph> 和 <codeph>updateDisplayList()</codeph> 方法。
	 
	 </apiDesc></apiParam><apiParam><apiItemName>skipDisplayList</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>如果为 <codeph>true</codeph>，则不调用 <codeph>validateDisplayList()</codeph> 和 <codeph>updateDisplayList()</codeph> 方法。
	  
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
	  当属性发生更改后，组件通常不会立即应用这些更改，而是会调用 LayoutManager 的一个 invalidate 方法，并在稍后应用这些属性。可以立即重新读取实际设置的属性，但如果该属性会影响组件或者其子项或父项中的其他属性，则可能不会立即更新这些受影响的属性。  
	 
	  <p>要保证已更新这些值，可以调用 <codeph>validateClient()</codeph> 方法。它会在返回之前更新嵌套级别大于或等于目标组件的所有组件中的所有属性。仅在必要时才调用此方法，因为调用此方法需要进行大量计算。</p>
	 
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ILayoutManager:mx.managers:ILayoutManager:validateNow"><apiName>validateNow</apiName><shortdesc>
	  当属性发生更改后，组件通常不会立即应用这些更改，</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
	  当属性发生更改后，组件通常不会立即应用这些更改，而是会调用 LayoutManager 的一个 invalidate 方法，并在稍后应用这些属性。可以立即重新读取实际设置的属性，但如果该属性会影响组件或者其子项或父项中的其他属性，则可能不会立即更新这些受影响的属性。要保证已更新这些值，可以调用 <codeph>validateNow()</codeph> 方法。它会在返回之前更新所有组件中的所有属性。仅在必要时才调用此方法，因为调用此方法需要进行大量计算。
	  
	  </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:ILayoutManager:mx.managers:ILayoutManager:usePhasedInstantiation:get"><apiName>usePhasedInstantiation</apiName><shortdesc>
	  一个标志，用于指示 LayoutManager 是否允许在各个阶段之间更新屏幕。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/></apiValueDef><apiDesc>
	  一个标志，用于指示 LayoutManager 是否允许在各个阶段之间更新屏幕。如果为 <codeph>true</codeph>，则在各阶段都会进行度量和布局，每个阶段结束后都会更新一次屏幕。所有组件都将调用其 <codeph>validateProperties()</codeph> 和 <codeph>commitProperties()</codeph> 方法，直到验证完各自的所有属性。屏幕将随之更新。  
	 
	  <p>然后，所有组件都将调用其 <codeph>validateSize()</codeph> 和 <codeph>measure()</codeph> 方法，直到测量完所有组件，屏幕也将再次更新。  </p>
	 
	  <p>最后，所有组件都将调用其 <codeph>validateDisplayList()</codeph> 和 <codeph>updateDisplayList()</codeph> 方法，直到验证完所有组件，屏幕也将再次更新。如果正在验证某个阶段，并且前面的阶段失效，则会重新启动 LayoutManager。当创建和初始化大量组件时，此方法更为高效。框架负责设置此属性。</p>
	 
	  <p>如果为 <codeph>false</codeph>，则会在更新屏幕之前完成所有这三个阶段。</p>
	  
	  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:FocusManager"><apiName>FocusManager</apiName><shortdesc>
  FocusManager 类管理组件上的焦点，以响应鼠标活动或键盘活动（Tab 键）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>mx.managers:IFocusManager</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
  FocusManager 类管理组件上的焦点，以响应鼠标活动或键盘活动（Tab 键）。一个应用程序中可以包含多个 FocusManager 实例。每个 FocusManager 实例负责一组可组成“Tab 键循环”的组件。如果单击 Tab 的次数足够多，焦点将遍历一组组件，最终返回到具有焦点的第一个组件。这就是一个“Tab 键循环”，由 FocusManager 实例管理此循环。如果弹出窗口本身包含一组可构成“Tab 键循环”的组件，那么这些弹出窗口将拥有自己的 FocusManager 实例。主应用程序通常都包含 FocusManager 实例。
   <p>FocusManager 管理“组件级别”的焦点。在 Flex 中，只有组件中的 UITextField 允许使用键盘输入文本。对于 Flash Player 或 AIR，该 UITextField 具有焦点。然而，从 FocusManager 的角度来说，具有焦点的却是作为 UITextField 的父项的组件。因此，组件级别的焦点与播放器级别的焦点是不同的。应用程序开发人员一般只需要处理组件级别的焦点，而组件开发人员则必须通晓播放器级别的焦点。</p>
   <p>可以由 FocusManager 管理的所有组件都必须实现 mx.managers.IFocusManagerComponent，但由播放器级别的焦点管理的对象则不必实现。</p>  
   <p>FocusManager 还可以管理 defaultButton 的概念，这是表单上的一个 Button，用于在按下 Enter 键时根据焦点当时所在的位置分派 click 事件。</p>
  
  </apiDesc></apiClassifierDetail><apiConstructor id="mx.managers:FocusManager:FocusManager"><apiName>FocusManager</apiName><shortdesc>
      构造函数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>container</apiItemName><apiOperationClassifier>mx.managers:IFocusManagerContainer</apiOperationClassifier><apiDesc>承载 FocusManager 的 IFocusManagerContainer。
           </apiDesc></apiParam><apiParam><apiItemName>popup</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>如果为 <codeph>true</codeph>，则表明该容器是一个弹出组件，而不是主应用程序。
      
      </apiDesc></apiParam></apiConstructorDef><apiDesc>
      构造函数。
           <p>FocusManager 管理 IFocusManagerContainer 的子项内的焦点。它会在执行构造函数期间在 IFocusManagerContainer 中自行安装。</p>
           </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="mx.managers:FocusManager:activate"><apiName>activate</apiName><shortdesc>
      如果同时有多个 IFocusManagerContainer 可见，则 SystemManager 将激活 FocusManager，然后取消激活。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      如果同时有多个 IFocusManagerContainer 可见，则 SystemManager 将激活 FocusManager，然后取消激活。如果在具有已取消激活 FocusManager 的 IFocusManagerContainer 中单击鼠标，则 SystemManager 将对该 FocusManager 调用 <codeph>activate()</codeph> 方法。已激活的 FocusManager 将首先调用自身的 <codeph>deactivate()</codeph> 方法，然后再激活另一个 FocusManager。
           <p>FocusManager 可以添加允许其监视与焦点相关的键盘和鼠标活动的事件处理程序。</p>
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:FocusManager:deactivate"><apiName>deactivate</apiName><shortdesc>
      如果同时有多个 IFocusManagerContainer 可见，则 SystemManager 将激活 FocusManager，然后取消激活。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      如果同时有多个 IFocusManagerContainer 可见，则 SystemManager 将激活 FocusManager，然后取消激活。如果在具有已取消激活 FocusManager 的 IFocusManagerContainer 中单击鼠标，则 SystemManager 将对该 FocusManager 调用 <codeph>activate()</codeph> 方法。已激活的 FocusManager 将首先调用自身的 <codeph>deactivate()</codeph> 方法，然后再激活另一个 FocusManager。
           <p>FocusManager 可以删除允许其监视与焦点相关的键盘和鼠标活动的事件处理程序。</p>
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:FocusManager:findFocusManagerComponent"><apiName>findFocusManagerComponent</apiName><shortdesc>
      
      返回包含给定对象（如果有）的 IFocusManagerComponent。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>包含 <codeph>o</codeph> 或 <codeph>null</codeph> 的 IFOcusManagerComponent
      
      </apiDesc><apiOperationClassifier>mx.managers:IFocusManagerComponent</apiOperationClassifier></apiReturn><apiParam><apiItemName>o</apiItemName><apiType value="flash.display:InteractiveObject"/><apiDesc>具有 Flash Player 级别的焦点的对象。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      
      返回包含给定对象（如果有）的 IFocusManagerComponent。因为播放器可以为 Flex 组件的子组件设置焦点，所以此方法可以从组件角度确定具有焦点的 IFocusManagerComponent。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:FocusManager:getFocus"><apiName>getFocus</apiName><shortdesc>
      
      获取当前具有焦点的 IFocusManagerComponent 组件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>具有焦点的 IFocusManagerComponent 对象。
      
      </apiDesc><apiOperationClassifier>mx.managers:IFocusManagerComponent</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      
      获取当前具有焦点的 IFocusManagerComponent 组件。建议调用此方法而不要使用 Stage 对象，因为此方法可以指示哪个组件具有焦点。Stage 可能会返回该组件中的子组件。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:FocusManager:getNextFocusManagerComponent"><apiName>getNextFocusManagerComponent</apiName><shortdesc>
      
      返回 IFocusManagerComponent，当用户按下 Tab 键导航到下一个组件时，它可以获取焦点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>要获得焦点的组件。
      
      </apiDesc><apiOperationClassifier>mx.managers:IFocusManagerComponent</apiOperationClassifier></apiReturn><apiParam><apiItemName>backward</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>如果为 <codeph>true</codeph>，则返回该对象，就像按下了 Shift-Tab 一样。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      
      返回 IFocusManagerComponent，当用户按下 Tab 键导航到下一个组件时，它可以获取焦点。如果应用程序中不存在其他的有效组件，则会返回与当前具有焦点的组件相同的组件。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:FocusManager:hideFocus"><apiName>hideFocus</apiName><shortdesc>
      
      将 showFocusIndicator 设置为 false，并从具有焦点的对象（如果有）上删除可视的焦点指示符。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      
      将 <codeph>showFocusIndicator</codeph> 设置为 <codeph>false</codeph>，并从具有焦点的对象（如果有）上删除可视的焦点指示符。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:FocusManager:setFocus"><apiName>setFocus</apiName><shortdesc>
      
      将焦点设置到 IFocusManagerComponent 组件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>o</apiItemName><apiOperationClassifier>mx.managers:IFocusManagerComponent</apiOperationClassifier><apiDesc>一个可以获得焦点的组件。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      
      将焦点设置到 IFocusManagerComponent 组件。此方法不检查组件的可见性、启用状态或任何其他条件。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:FocusManager:showFocus"><apiName>showFocus</apiName><shortdesc>
      
      将 showFocusIndicator 设置为 true，并在具有焦点的对象（如果有）上绘制可视的焦点指示符。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      
      将 <codeph>showFocusIndicator</codeph> 设置为 <codeph>true</codeph>，并在具有焦点的对象（如果有）上绘制可视的焦点指示符。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:FocusManager:toString"><apiName>toString</apiName><shortdesc>
      返回承载 FocusManager 对象的组件的字符串表示形式，并在该字符串末尾追加字符串“.focusManager”。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>返回承载 FocusManager 对象的组件的字符串表示形式，并在该字符串末尾追加字符串<codeph>".focusManager"</codeph>。
      
      </apiDesc><apiType value="String"/></apiReturn></apiOperationDef><apiDesc>
      返回承载 FocusManager 对象的组件的字符串表示形式，并在该字符串末尾追加字符串<codeph>".focusManager"</codeph>。
           </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:FocusManager:defaultButtonEnabled:get"><apiName>defaultButtonEnabled</apiName><shortdesc>
      
      一个标志，指示 FocusManager 是否应检查为激活默认按钮而要按下的 Enter 键。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/></apiValueDef><apiDesc>
      
      一个标志，指示 FocusManager 是否应检查为激活默认按钮而要按下的 Enter 键。TextArea 和希望识别 <codeph>Enter</codeph> 键的其他组件将此属性设置为 <codeph>false</codeph>，以禁止 Enter 键分派默认按钮上的 <codeph>click</codeph> 事件（如果存在）。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:FocusManager:defaultButton:get"><apiName>defaultButton</apiName><shortdesc>
      
      对原始的默认 Button 控件的引用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>mx.core:IButton</apiValueClassifier></apiValueDef><apiDesc>
      
      对原始的默认 Button 控件的引用。当任何控件上有焦点时按 Enter 键可分派 Button 控件上的 <codeph>click</codeph> 事件，从而激活 Button 控件，效果与单击鼠标相同。如果将焦点授予了其他 Button 控件，却在当焦点不在按钮上时将焦点切换回原始控件，则默认 Button 控件实际上发生了更改。
     
      <p>此属性由 Flex 容器管理；请勿直接设置此属性来指定默认按钮。</p>
     
      <p><codeph>defaultButton</codeph> 必须属于 <codeph>mx.controls.Button</codeph> 类，即使此属性属于 <codeph>IUIComponent</codeph> 类型也不例外。</p>
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:FocusManager:focusPane:get"><apiName>focusPane</apiName><shortdesc>
      
      随着焦点在各容器之间移动的单个 Sprite。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="flash.display:Sprite"/></apiValueDef><apiDesc>
      
      随着焦点在各容器之间移动的单个 Sprite。Sprite 将作为用于指示组件具有焦点的可视指示符的父项。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:FocusManager:nextTabIndex:get"><apiName>nextTabIndex</apiName><shortdesc>
      
      此 Tab 键循环中要用到的下一个唯一的 tab 索引。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="int"/></apiValueDef><apiDesc>
      
      此 Tab 键循环中要用到的下一个唯一的 tab 索引。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:FocusManager:showFocusIndicator:get"><apiName>showFocusIndicator</apiName><shortdesc>
      
      一个标志，指示是否显示用于指示组件具有焦点的指示符。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/></apiValueDef><apiDesc>
      
      一个标志，指示是否显示用于指示组件具有焦点的指示符。如果为 <codeph>true</codeph>，则获得焦点的组件将绘制一个可视指示符，指示它具有焦点。
     
      <p>默认为 <codeph>false</codeph>，如果用户使用 Tab 键，则将其设为 <codeph>true</codeph>。</p>
     
      <p>通常情况下，最好使用 <codeph>showFocus()</codeph> 和 <codeph>hideFocus()</codeph> 方法更改此属性，因为这些方法还会更新用于指示组件具有焦点的可视指示符。</p>
      
      </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:IFocusManagerComplexComponent"><apiName>IFocusManagerComplexComponent</apiName><shortdesc>
  IFocusManagerComplexComponent 接口可定义一类接口，可以拥有多个内部焦点目标的组件必须实现此类接口才能获得来自 FocusManager 的焦点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>mx.managers:IFocusManagerComponent</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
  IFocusManagerComplexComponent 接口可定义一类接口，可以拥有多个内部焦点目标的组件必须实现此类接口才能获得来自 FocusManager 的焦点。
  
  </apiDesc></apiClassifierDetail><apiOperation id="mx.managers:IFocusManagerComplexComponent:mx.managers:IFocusManagerComplexComponent:assignFocus"><apiName>assignFocus</apiName><shortdesc>
	  当组件获得焦点时，由 FocusManager 调用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>direction</apiItemName><apiType value="String"/><apiDesc>如果 Tab 键和 Shift 键同时使用，则为“bottom”；否则，为“top”。
	  
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
	  当组件获得焦点时，由 FocusManager 调用。同样，该组件可以将焦点设置给某个内部组件。当通过鼠标设置焦点时，仍将调用组件的 setFocus() 方法，但当通过键盘更改焦点时，将使用此方法。
	 
	  </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:IFocusManagerComplexComponent:mx.managers:IFocusManagerComplexComponent:hasFocusableContent:get"><apiName>hasFocusableContent</apiName><shortdesc>
	  一个标志，指示组件当前是否具有可获得焦点的内部目标
	 
	  
	  </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
	  一个标志，指示组件当前是否具有可获得焦点的内部目标
	 
	  
	  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:IBrowserManager"><apiName>IBrowserManager</apiName><shortdesc>
  由 BrowserManager 的共享实例实现的接口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.events:IEventDispatcher</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
  由 BrowserManager 的共享实例实现的接口。应用程序可在使用 <codeph>BrowserManager.getInstance()</codeph> 方法访问的共享实例上侦听事件、调用方法以及访问属性。
 
  </apiDesc></apiClassifierDetail><related-links><link href="mx.managers.xml#BrowserManager"><linktext>mx.managers.BrowserManager</linktext></link></related-links><adobeApiEvent id="mx.managers:IBrowserManager_mx.events.BrowserChangeEvent.URL_CHANGE_urlChange"><apiName>urlChange</apiName><shortdesc>
  当应用程序更改 URL 时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>mx.events.BrowserChangeEvent.URL_CHANGE</apiEventType><adobeApiEventClassifier>mx.events.BrowserChangeEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  当应用程序更改 URL 时分派。
 
  </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="mx.managers:IBrowserManager_mx.events.BrowserChangeEvent.BROWSER_URL_CHANGE_browserURLChange"><apiName>browserURLChange</apiName><shortdesc>
  当浏览器更改 URL 时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>mx.events.BrowserChangeEvent.BROWSER_URL_CHANGE</apiEventType><adobeApiEventClassifier>mx.events.BrowserChangeEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  当浏览器更改 URL 时分派。
 
  </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="mx.managers:IBrowserManager_flash.events.Event.CHANGE_change"><apiName>change</apiName><shortdesc>
  当通过用户与浏览器交互、调用 AIR 中的应用程序或以编程方式设置此属性来更改 URL 时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.CHANGE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  当通过用户与浏览器交互、调用 AIR 中的应用程序或以编程方式设置此属性来更改 URL 时分派。
 
  </apiDesc></adobeApiEventDetail></adobeApiEvent><apiOperation id="mx.managers:IBrowserManager:mx.managers:IBrowserManager:initForHistoryManager"><apiName>initForHistoryManager</apiName><shortdesc> 
      初始化 BrowserManager。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc> 
      初始化 BrowserManager。HistoryManager 调用此方法来准备 BrowserManager，供 HistoryManager 以后调用。无法从应用程序中使用 HistoryManager 调用 <codeph>setFragment()</codeph> 方法。因此，<codeph>init()</codeph> 方法通常将 <codeph>ApplicationGlobals.application.historyManagementEnabled</codeph> 属性的值设置为 <codeph>false</codeph>，以禁用 HistoryManager。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IBrowserManager:mx.managers:IBrowserManager:init"><apiName>init</apiName><shortdesc> 
      初始化 BrowserManager。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="String"/><apiData>null</apiData><apiDesc>当初始 URL 中没有片段时使用的片段。
      </apiDesc></apiParam><apiParam><apiItemName>title</apiItemName><apiType value="String"/><apiData>null</apiData><apiDesc>当初始 URL 中没有片段时使用的标题。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc> 
      初始化 BrowserManager。BrowserManager 将获取初始 URL。如果它包含片段，则分派 <codeph>BROWSER_URL_CHANGE</codeph> 事件。此方法将 <codeph>ApplicationGlobals.application.historyManagementEnabled</codeph> 属性的值设置为 <codeph>false</codeph>，这是因为 HistoryManager 通常会干扰应用程序的 URL 段处理。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IBrowserManager:mx.managers:IBrowserManager:setFragment"><apiName>setFragment</apiName><shortdesc> 
      更改浏览器中“#”后面的 URL 片段。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="String"/><apiDesc>URL 中“#”之后要使用的新片段。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc> 
      更改浏览器中“#”后面的 URL 片段。系统将尝试在浏览器历史记录中跟踪此 URL。
     
      <p>如果设置了标题，则浏览器中的旧标题将被新标题取代。</p>
     
      <p>若要存储 URL，则需调用称为 <codeph>setBrowserURL()</codeph> 的 JavaScript 方法。应用程序的 HTML 包装中必须包含该方法，该方法必须实现一种机制来采用此值并向浏览器的历史记录架构和地址栏注册此值。</p>
     
      <p>设置完成后，分派 <codeph>APPLICATION_URL_CHANGE</codeph> 事件。如果取消此事件，则不会调用 <codeph>setBrowserURL()</codeph> 方法。</p>
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IBrowserManager:mx.managers:IBrowserManager:setTitle"><apiName>setTitle</apiName><shortdesc> 
      更改浏览器标题栏中的文本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="String"/><apiDesc>浏览器的标题栏中要使用的新标题。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc> 
      更改浏览器标题栏中的文本。此方法不会影响浏览器的历史记录。
     
     </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:IBrowserManager:mx.managers:IBrowserManager:base:get"><apiName>base</apiName><shortdesc>
      当前 URL 显示在浏览器地址栏中时，“#”之前的部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="String"/></apiValueDef><apiDesc>
      当前 URL 显示在浏览器地址栏中时，“#”之前的部分。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:IBrowserManager:mx.managers:IBrowserManager:fragment:get"><apiName>fragment</apiName><shortdesc>
      当前 URL 显示在浏览器地址栏中时，“#”之后的部分。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="String"/></apiValueDef><apiDesc>
      当前 URL 显示在浏览器地址栏中时，“#”之后的部分。使用 <codeph>setURLFragment()</codeph> 方法可更改此值。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:IBrowserManager:mx.managers:IBrowserManager:title:get"><apiName>title</apiName><shortdesc>
      应用程序在浏览器历史记录中应显示的标题。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="String"/></apiValueDef><apiDesc>
      应用程序在浏览器历史记录中应显示的标题。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:IBrowserManager:mx.managers:IBrowserManager:url:get"><apiName>url</apiName><shortdesc>
      当前显示在浏览器地址栏中的 URL。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="String"/></apiValueDef><apiDesc>
      当前显示在浏览器地址栏中的 URL。  
      
      </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:PopUpManager"><apiName>PopUpManager</apiName><shortdesc>
  PopUpManager singleton 类用于创建新的顶级窗口，还可以在位于所有其它可见窗口上面的层次中放置或删除这些窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
  PopUpManager singleton 类用于创建新的顶级窗口，还可以在位于所有其他可见窗口上面的层次中放置或删除这些窗口。有关分层的说明，请参见 SystemManager。此类适用于 ComboBox 控件中的弹出对话框、菜单和下拉列表等类似组件。
 
  <p>PopUpManager 还可以提供模态，使弹出窗口下方的窗口无法接收鼠标事件；当用户在窗口外部单击鼠标时，它还可以提供一个事件，供开发人员选择退出窗口还是警告用户。</p>
 
  </apiDesc></apiClassifierDetail><related-links><link href="mx.managers.xml#PopUpManagerChildList"><linktext>PopUpManagerChildList</linktext></link></related-links><apiOperation id="mx.managers:PopUpManager:addPopUp"><apiName>addPopUp</apiName><shortdesc>
      弹出顶级窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>window</apiItemName><apiOperationClassifier>mx.core:IFlexDisplayObject</apiOperationClassifier><apiDesc>要弹出的 IFlexDisplayObject。
     
      </apiDesc></apiParam><apiParam><apiItemName>parent</apiItemName><apiType value="flash.display:DisplayObject"/><apiDesc>DisplayObject，用于确定要使用 SystemManager 的哪些层，以及（可选）确定居中新的顶级窗口所用的参考点。它可能并非弹出窗口的实际父项，因为所有弹出窗口都以 SystemManager 为父项。
     
      </apiDesc></apiParam><apiParam><apiItemName>modal</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>如果为 <codeph>true</codeph>，则该窗口为模态窗口，也就是说在删除该窗口之前，用户将无法与其他弹出窗口交互。
     
      </apiDesc></apiParam><apiParam><apiItemName>childList</apiItemName><apiType value="String"/><apiData>null</apiData><apiDesc>要将弹出窗口添加到其中的子项列表。<codeph>PopUpManagerChildList.APPLICATION</codeph>、<codeph>PopUpManagerChildList.POPUP</codeph> 或 <codeph>PopUpManagerChildList.PARENT</codeph>（默认）中的任意一项。
     
      </apiDesc></apiParam><apiParam><apiItemName>moduleFactory</apiItemName><apiOperationClassifier>mx.core:IFlexModuleFactory</apiOperationClassifier><apiData>null</apiData><apiDesc>此弹出窗口应在其中查找其嵌入字体和样式管理器的 moduleFactory。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      弹出顶级窗口。最好调用 <codeph>removePopUp()</codeph> 来删除使用 <codeph>addPopUp()</codeph> 方法创建的弹出窗口。如果该类实现了 IFocusManagerContainer，则该窗口将拥有自己的 FocusManager；因此，当用户使用 Tab 键在各个控件之间导航时，将只能访问此窗口中的控件。
     
      <p><b>示例</b></p> 
     
      <pre>var tw:TitleWindow = new TitleWindow();
        tw.title = "My Title";
        mx.managers.PopUpManager.addPopUp(tw, pnl, false);</pre>
     
      <p>使用 TitleWindow 类的 <codeph>tw</codeph> 实例创建一个弹出窗口，并使用 <codeph>pnl</codeph> 作为 Sprite 来确定放置此弹出窗口的位置。此窗口将定义为非模态窗口。</p>
      
      </apiDesc></apiOperationDetail><related-links><link href="mx.managers.xml#PopUpManagerChildList"><linktext>PopUpManagerChildList</linktext></link></related-links></apiOperation><apiOperation id="mx.managers:PopUpManager:bringToFront"><apiName>bringToFront</apiName><shortdesc>
      请确保弹出窗口高于其子项列表中的其他对象。如果该弹出窗口是顶级窗口并且位于鼠标下，则 SystemManager 会自动将其设置为满足此要求；否则，您必须自行处理。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>popUp</apiItemName><apiOperationClassifier>mx.core:IFlexDisplayObject</apiOperationClassifier><apiDesc>表示弹出窗口的 IFlexDisplayObject。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      请确保弹出窗口高于其子项列表中的其他对象。如果该弹出窗口是顶级窗口并且位于鼠标下，则 SystemManager 会自动将其设置为满足此要求；否则，您必须自行处理。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:PopUpManager:centerPopUp"><apiName>centerPopUp</apiName><shortdesc>
      使位于调用 createPopUp() 或 addPopUp() 方法期间使用的任何窗口上面的弹出窗口居中显示。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>popUp</apiItemName><apiOperationClassifier>mx.core:IFlexDisplayObject</apiOperationClassifier><apiDesc>表示弹出窗口的 IFlexDisplayObject。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      使位于调用 <codeph>createPopUp()</codeph> 或 <codeph>addPopUp()</codeph> 方法期间使用的任何窗口上面的弹出窗口居中显示。
     
      <p>请注意，由于 Flex 可能会在居中弹出窗口前对其进行测量和布局，因此弹出窗口的位置可能不会在完成此调用后立即更改。</p>
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:PopUpManager:createPopUp"><apiName>createPopUp</apiName><shortdesc>
      创建一个顶级窗口，并按 z 轴顺序将其置于其他窗口上方。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>对新的顶级窗口的引用。
     
      </apiDesc><apiOperationClassifier>mx.core:IFlexDisplayObject</apiOperationClassifier></apiReturn><apiParam><apiItemName>parent</apiItemName><apiType value="flash.display:DisplayObject"/><apiDesc>DisplayObject，用于确定要使用 SystemManager 的哪些层，以及（可选）确定居中新的顶级窗口所用的参考点。它可能并非弹出窗口的实际父项，因为所有弹出窗口都以 SystemManager 为父项。
     
      </apiDesc></apiParam><apiParam><apiItemName>className</apiItemName><apiType value="Class"/><apiDesc>要为弹出窗口创建的对象的类。该类必须实现 IFlexDisplayObject。
     
      </apiDesc></apiParam><apiParam><apiItemName>modal</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>如果为 <codeph>true</codeph>，则该窗口为模态窗口，也就是说在删除该窗口之前，用户将无法与其他弹出窗口交互。
     
      </apiDesc></apiParam><apiParam><apiItemName>childList</apiItemName><apiType value="String"/><apiData>null</apiData><apiDesc>要将弹出窗口添加到的子项列表。<codeph>PopUpManagerChildList.APPLICATION</codeph>、<codeph>PopUpManagerChildList.POPUP</codeph> 或 <codeph>PopUpManagerChildList.PARENT</codeph>（默认）中的任意一项。
     
      </apiDesc></apiParam><apiParam><apiItemName>moduleFactory</apiItemName><apiOperationClassifier>mx.core:IFlexModuleFactory</apiOperationClassifier><apiData>null</apiData><apiDesc>此弹出窗口应在其中查找其嵌入字体和样式管理器的 moduleFactory。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      创建一个顶级窗口，并按 z 轴顺序将其置于其他窗口上方。最好调用 <codeph>removePopUp()</codeph> 方法来删除使用 <codeph>createPopUp()</codeph> 方法创建的弹出窗口。如果该类实现了 IFocusManagerContainer，则该窗口将拥有自己的 FocusManager；因此，当用户使用 Tab 键在各个控件之间导航时，将只能访问此窗口中的控件。
     
      <p><b>示例</b></p> 
     
      <pre>pop = mx.managers.PopUpManager.createPopUp(pnl, TitleWindow, false); </pre>
      
      <p>基于 TitleWindow 类创建一个弹出窗口，并使用 <codeph>pnl</codeph> 作为 MovieClip 来确定放置此弹出窗口的位置。此窗口将定义为非模态窗口，即其他窗口也可以接收鼠标事件</p>
     
      </apiDesc></apiOperationDetail><related-links><link href="mx.managers.xml#PopUpManagerChildList"><linktext>PopUpManagerChildList</linktext></link></related-links></apiOperation><apiOperation id="mx.managers:PopUpManager:removePopUp"><apiName>removePopUp</apiName><shortdesc>
      删除由 createPopUp() 或 addPopUp() 方法弹出的弹出窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>popUp</apiItemName><apiOperationClassifier>mx.core:IFlexDisplayObject</apiOperationClassifier><apiDesc>表示弹出窗口的 IFlexDisplayObject。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      删除由 <codeph>createPopUp()</codeph> 或 <codeph>addPopUp()</codeph> 方法弹出的弹出窗口。
      
      </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="mx.managers:IFocusManager"><apiName>IFocusManager</apiName><shortdesc>
  IFocusManager 接口可定义一类接口，组件必须实现此类接口才能管理组件中的焦点以响应鼠标活动或键盘活动（Tab 键），才能支持默认按钮。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.events:IEventDispatcher</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
  IFocusManager 接口可定义一类接口，组件必须实现此类接口才能管理组件中的焦点以响应鼠标活动或键盘活动（Tab 键），才能支持默认按钮。
 
  </apiDesc></apiClassifierDetail><related-links><link href="mx.managers.xml#FocusManager"><linktext>mx.managers.FocusManager</linktext></link></related-links><apiOperation id="mx.managers:IFocusManager:mx.managers:IFocusManager:activate"><apiName>activate</apiName><shortdesc>
      如果同时有多个 IFocusManagerContainer 可见，则 SystemManager 将激活 FocusManager，然后取消激活。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      如果同时有多个 IFocusManagerContainer 可见，则 SystemManager 将激活 FocusManager，然后取消激活。如果在具有已取消激活 FocusManager 的 IFocusManagerContainer 中单击鼠标，则 SystemManager 将对该 FocusManager 调用 <codeph>activate()</codeph> 方法。已激活的 FocusManager 将首先调用自身的 <codeph>deactivate()</codeph> 方法，然后再激活另一个 FocusManager。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IFocusManager:mx.managers:IFocusManager:deactivate"><apiName>deactivate</apiName><shortdesc>
      如果同时有多个 IFocusManagerContainer 可见，则 SystemManager 将激活 FocusManager，然后取消激活。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      如果同时有多个 IFocusManagerContainer 可见，则 SystemManager 将激活 FocusManager，然后取消激活。如果在具有已取消激活 FocusManager 的 IFocusManagerContainer 中单击鼠标，则 SystemManager 将对该 FocusManager 调用 <codeph>activate()</codeph> 方法。已激活的 FocusManager 将首先调用自身的 <codeph>deactivate()</codeph> 方法，然后再激活另一个 FocusManager。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IFocusManager:mx.managers:IFocusManager:findFocusManagerComponent"><apiName>findFocusManagerComponent</apiName><shortdesc>
      返回包含给定对象（如果有）的 IFocusManagerComponent。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>包含 <codeph>o</codeph> 或 <codeph>null</codeph> 的 IFOcusManagerComponent
      
      </apiDesc><apiOperationClassifier>mx.managers:IFocusManagerComponent</apiOperationClassifier></apiReturn><apiParam><apiItemName>o</apiItemName><apiType value="flash.display:InteractiveObject"/><apiDesc>具有 Flash Player 级别的焦点的对象。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      返回包含给定对象（如果有）的 IFocusManagerComponent。因为播放器可以为 Flex 组件的子组件设置焦点，所以此方法可以从组件角度确定具有焦点的 IFocusManagerComponent。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IFocusManager:mx.managers:IFocusManager:getFocus"><apiName>getFocus</apiName><shortdesc>
      获取当前具有焦点的 IFocusManagerComponent 组件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>具有焦点的 IFocusManagerComponent 对象。
      
      </apiDesc><apiOperationClassifier>mx.managers:IFocusManagerComponent</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      获取当前具有焦点的 IFocusManagerComponent 组件。建议调用此方法而不要使用 Stage 对象，因为此方法可以指示哪个组件具有焦点。Stage 可能会返回该组件中的子组件。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IFocusManager:mx.managers:IFocusManager:getNextFocusManagerComponent"><apiName>getNextFocusManagerComponent</apiName><shortdesc>
      返回 IFocusManagerComponent，当用户按下 Tab 键导航到下一个组件时，它可以获取焦点。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>要获得焦点的组件。
      
      </apiDesc><apiOperationClassifier>mx.managers:IFocusManagerComponent</apiOperationClassifier></apiReturn><apiParam><apiItemName>backward</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>如果为 <codeph>true</codeph>，则返回该对象，就像按下了 Shift-Tab 一样。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      返回 IFocusManagerComponent，当用户按下 Tab 键导航到下一个组件时，它可以获取焦点。如果应用程序中不存在其他的有效组件，则会返回与当前具有焦点的组件相同的组件。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IFocusManager:mx.managers:IFocusManager:hideFocus"><apiName>hideFocus</apiName><shortdesc>
      将 showFocusIndicator 设置为 false，并从具有焦点的对象（如果有）上删除可视的焦点指示符。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      将 <codeph>showFocusIndicator</codeph> 设置为 <codeph>false</codeph>，并从具有焦点的对象（如果有）上删除可视的焦点指示符。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IFocusManager:mx.managers:IFocusManager:setFocus"><apiName>setFocus</apiName><shortdesc>
      将焦点设置到 IFocusManagerComponent 组件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>o</apiItemName><apiOperationClassifier>mx.managers:IFocusManagerComponent</apiOperationClassifier><apiDesc>一个可以获得焦点的组件。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      将焦点设置到 IFocusManagerComponent 组件。此方法不检查组件的可见性、启用状态或任何其他条件。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IFocusManager:mx.managers:IFocusManager:showFocus"><apiName>showFocus</apiName><shortdesc>
      将 showFocusIndicator 设置为 true，并在具有焦点的对象（如果有）上绘制可视的焦点指示符。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      将 <codeph>showFocusIndicator</codeph> 设置为 <codeph>true</codeph>，并在具有焦点的对象（如果有）上绘制可视的焦点指示符。
      
      </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:IFocusManager:mx.managers:IFocusManager:defaultButtonEnabled:get"><apiName>defaultButtonEnabled</apiName><shortdesc>
      一个标志，指示 FocusManager 是否应检查为激活默认按钮而要按下的 Enter 键。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/></apiValueDef><apiDesc>
      一个标志，指示 FocusManager 是否应检查为激活默认按钮而要按下的 Enter 键。TextArea 和希望识别 <codeph>Enter</codeph> 键的其他组件将此属性设置为 <codeph>false</codeph>，以禁止 Enter 键分派默认按钮上的 <codeph>click</codeph> 事件（如果存在）。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:IFocusManager:mx.managers:IFocusManager:defaultButton:get"><apiName>defaultButton</apiName><shortdesc>
      对原始的默认 Button 控件的引用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>mx.core:IButton</apiValueClassifier></apiValueDef><apiDesc>
      对原始的默认 Button 控件的引用。当任何控件上有焦点时按 Enter 键可分派 Button 控件上的 <codeph>click</codeph> 事件，从而激活 Button 控件，效果与单击鼠标相同。如果将焦点授予了其他 Button 控件，却在当焦点不在按钮上时将焦点切换回原始控件，则默认 Button 控件实际上发生了更改。
     
      <p>此属性由 Flex 容器管理；请勿直接设置此属性来指定默认按钮。</p>
     
      <p><codeph>defaultButton</codeph> 必须属于 <codeph>mx.controls.Button</codeph> 类，即使此属性属于 <codeph>IUIComponent</codeph> 类型也不例外。</p>
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:IFocusManager:mx.managers:IFocusManager:focusPane:get"><apiName>focusPane</apiName><shortdesc>
      随着焦点在各容器之间移动的单个 Sprite。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="flash.display:Sprite"/></apiValueDef><apiDesc>
      随着焦点在各容器之间移动的单个 Sprite。Sprite 将作为用于指示组件具有焦点的可视指示符的父项。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:IFocusManager:mx.managers:IFocusManager:nextTabIndex:get"><apiName>nextTabIndex</apiName><shortdesc>
      此 Tab 键循环中要用到的下一个唯一的 tab 索引。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="int"/></apiValueDef><apiDesc>
      此 Tab 键循环中要用到的下一个唯一的 tab 索引。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:IFocusManager:mx.managers:IFocusManager:showFocusIndicator:get"><apiName>showFocusIndicator</apiName><shortdesc>
      一个标志，指示是否显示用于指示组件具有焦点的指示符。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/></apiValueDef><apiDesc>
      一个标志，指示是否显示用于指示组件具有焦点的指示符。如果为 <codeph>true</codeph>，则获得焦点的组件将绘制一个可视指示符，指示它具有焦点。
     
      <p>默认为 <codeph>false</codeph>，如果用户使用 Tab 键，则将其设为 <codeph>true</codeph>。</p>
     
      <p>通常情况下，最好使用 <codeph>showFocus()</codeph> 和 <codeph>hideFocus()</codeph> 方法更改此属性，因为这些方法还会更新用于指示组件具有焦点的可视指示符。</p>
      
      </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:IFocusManagerGroup"><apiName>IFocusManagerGroup</apiName><shortdesc>
  IFocusManagerGroup 接口可定义一类接口，分组后归到具有以下特征的集中的任何组件都必须实现此类接口：在任何给定的时刻，都只能选择集中的一个成员。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
  IFocusManagerGroup 接口可定义一类接口，分组后归到具有以下特征的集中的任何组件都必须实现此类接口：在任何给定的时刻，都只能选择集中的一个成员。例如，RadioButton 实现 IFocusManagerGroup，因为在任一时刻，同一组中的一系列 RadioButton 只可以有一个 RadioButton 被选中，并且 FocusManager 需要确保不为那些未被选中去响应使用 Tab 键移动焦点的 RadioButton 提供焦点。
  
  </apiDesc></apiClassifierDetail><apiValue id="mx.managers:IFocusManagerGroup:mx.managers:IFocusManagerGroup:groupName:get"><apiName>groupName</apiName><shortdesc>
	 该控件所属控件组的名称。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="String"/></apiValueDef><apiDesc>
	 该控件所属控件组的名称。
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:IFocusManagerGroup:mx.managers:IFocusManagerGroup:selected:get"><apiName>selected</apiName><shortdesc>
	 一个标志，指示是否已选中此控件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/></apiValueDef><apiDesc>
	 一个标志，指示是否已选中此控件。
	  
	  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:SystemManager"><apiName>SystemManager</apiName><shortdesc>
  SystemManager 类管理应用程序窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>mx.core:IChildList</apiBaseInterface><apiBaseInterface>mx.core:IFlexDisplayObject</apiBaseInterface><apiBaseInterface>mx.core:IFlexModuleFactory</apiBaseInterface><apiBaseInterface>mx.managers:ISystemManager</apiBaseInterface><apiBaseClassifier>flash.display:MovieClip</apiBaseClassifier></apiClassifierDef><apiDesc>
  SystemManager 类管理应用程序窗口。桌面上或浏览器中运行的每个应用程序中都有一个区域，用于显示应用程序的可视部分。该区域可能是操作系统中的某个窗口，也可能是浏览器中的某个区域。此区域是一个不同于 <codeph>mx.core.Application</codeph> 实例的应用程序窗口，前者是应用程序中的主窗口（即顶级主窗口）。
   <p>每个应用程序都包含一个 SystemManager。如果应用程序窗口的大小发生更改（您无法在应用程序中更改其大小，只能通过与操作系统窗口或浏览器交互来进行更改），则 SystemManager 会发送一个事件。它是应用程序中所有可显示项目（例如 mx.core.Application 主实例以及所有弹出窗口、工具提示、光标等）的父项。任何以 SystemManager 作为父项的对象都将被视为“顶级”窗口，就连工具提示和光标也是如此。</p>
   <p>如果显示有多个 IFocusManagerContainer，并且用户正在与 IFocusManagerContainers 中的组件进行交互，则 SystemManager 还可以在顶级窗口之间切换焦点。  </p>
   <p>使用 SystemManager 可以查看所有并非显式捕获的键盘和鼠标活动，所以，如有必要，可以使用它来监视活动。</p>
   <p>在将某个应用程序加载到另一个应用程序时，虽然仍会创建 SystemManager，但是根据安全性和域规则，将不会使用它来管理“应用程序窗口”。而将作为加载它的 <codeph>Loader</codeph> 的 <codeph>content</codeph>，只是充当子应用程序的父级。</p>
   <p>SystemManager 可维护多个子项列表，工具提示、光标、弹出窗口各有一个列表。因此，它可以确保弹出窗口“浮”在主应用程序窗口上方，工具提示“浮”在弹出窗口上方，光标“浮”在工具提示上方。如果只对 SystemManager 检查 <codeph>numChildren</codeph> 属性或调用 <codeph>getChildAt()</codeph> 方法，则需要访问主应用程序窗口以及其他任何没有弹出的窗口。要获得所有窗口（包括弹出窗口、工具提示和光标）的列表，请使用 <codeph>rawChildren</codeph> 属性。</p>
   <p>SystemManager 是在应用程序中创建的第一个显示类。它负责创建要显示的 <codeph>mx.preloaders.Preloader</codeph> 以及应用程序完成加载时显示的 <codeph>mx.preloaders.SparkDownloadProgressBar</codeph>，然后创建 <codeph>mx.core.Application</codeph> 实例。</p>
  
  </apiDesc></apiClassifierDetail><adobeApiEvent id="mx.managers:SystemManager_flash.events.Event.RESIZE_resize"><apiName>resize</apiName><shortdesc>
  当调整舞台大小时分派。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>flash.events.Event.RESIZE</apiEventType><adobeApiEventClassifier>flash.events.Event</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  当调整舞台大小时分派。
   </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="mx.managers:SystemManager_mx.events.FlexEvent.IDLE_idle"><apiName>idle</apiName><shortdesc>
  当 1 秒内没有任何键盘和鼠标活动时，每隔 100 毫秒分派一次。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>mx.events.FlexEvent.IDLE</apiEventType><adobeApiEventClassifier>mx.events.FlexEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  当 1 秒内没有任何键盘和鼠标活动时，每隔 100 毫秒分派一次。
   </apiDesc></adobeApiEventDetail></adobeApiEvent><adobeApiEvent id="mx.managers:SystemManager_mx.events.FlexEvent.APPLICATION_COMPLETE_applicationComplete"><apiName>applicationComplete</apiName><shortdesc>
  当应用程序完成初始化时分派。
   </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><adobeApiEventDetail><adobeApiEventDef><apiEventType>mx.events.FlexEvent.APPLICATION_COMPLETE</apiEventType><adobeApiEventClassifier>mx.events.FlexEvent</adobeApiEventClassifier><apiGeneratedEvent/></adobeApiEventDef><apiDesc>
  当应用程序完成初始化时分派。
   </apiDesc></adobeApiEventDetail></adobeApiEvent><apiConstructor id="mx.managers:SystemManager:SystemManager"><apiName>SystemManager</apiName><shortdesc>
      构造函数。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef><apiDesc>
      构造函数。
           <p>这是所有 Flex 应用程序的起点。此类将设置为 Flex SWF 文件的根类。Flash Player 实例化此类的实例，从而导致调用此构造函数。</p>
      
      </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="mx.managers:SystemManager:addPreloadedRSL"><apiName>addPreloadedRSL</apiName><shortdesc>
      
      将 RSL 添加到 preloadedRSLs 列表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="4.5"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>loaderInfo</apiItemName><apiType value="flash.display:LoaderInfo"/><apiDesc>已加载的 RSL 的 loaderInfo。
      </apiDesc></apiParam><apiParam><apiItemName>rsl</apiItemName><apiType value="Vector$mx.core:RSLData"/><apiDesc>RSL 的配置信息。RSLData 的矢量。数组中的第一个元素为主 RSL。其余元素为故障转移 RSL。
           </apiDesc></apiParam></apiOperationDef><apiDesc>
      
      将 RSL 添加到 preloadedRSLs 列表。子模块工厂将 RSL 加载到该模块工厂的应用程序域中时会调用此方法。
           <p>您无需直接调用此方法。子模块工厂将 RSL 加载到该模块工厂的应用程序域中时会调用此方法。</p>
           </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:allowDomain"><apiName>allowDomain</apiName><shortdesc>
      为与 SystemManager 关联的 SWF 和与 SystemManager 预加载的 RSL 关联的所有 SWF 调用 Security.allowDomain()。</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>domains</apiItemName><apiType value="restParam"/></apiParam></apiOperationDef><apiDesc>
      为与 SystemManager 关联的 SWF 和与 SystemManager 预加载的 RSL 关联的所有 SWF 调用 Security.allowDomain()。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:allowInsecureDomain"><apiName>allowInsecureDomain</apiName><shortdesc>
      为与 SystemManager 关联的 SWF 和与 SystemManager 预加载的 RSL 关联的所有 SWF 调用 Security.allowInsecureDomain()。</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>domains</apiItemName><apiType value="restParam"/></apiParam></apiOperationDef><apiDesc>
      为与 SystemManager 关联的 SWF 和与 SystemManager 预加载的 RSL 关联的所有 SWF 调用 Security.allowInsecureDomain()。
     
     </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:create"><apiName>create</apiName><shortdesc>
      factory 方法，要求定义的实例是模块已知的。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>模块实例，或 <codeph>null</codeph>。
      
      </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>params</apiItemName><apiType value="restParam"/><apiDesc>可选参数列表。您可以传递任何数目的参数，这些参数将存储在名为 <codeph>parameters</codeph> 的 Array 中。 
           </apiDesc></apiParam></apiOperationDef><apiDesc>
      factory 方法，要求定义的实例是模块已知的。您可以提供可选参数集，以便构建工厂根据输入内容更改它们创建的内容。传递 null 指示，如果可能的话，创建默认的定义。在自动生成的子类中将覆盖此方法。
           </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:deployMouseShields"><apiName>deployMouseShields</apiName><shortdesc>
      
      部署或删除鼠标盾。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>deploy</apiItemName><apiType value="Boolean"/><apiDesc><codeph>true</codeph> 将部署鼠标盾，<codeph>false</codeph> 将删除鼠标盾。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      
      部署或删除鼠标盾。鼠标盾可以阻止不受信任的应用程序获得鼠标输入。之所以需要阻止鼠标输入，是因为在不受信任的应用程序上拖动时，一般不会收到任何鼠标移动事件。出于安全考虑，Flash Player 在穿越受信任/不受信任的边界时不发送事件。通过用鼠标盾（假设您是其父级）遮盖不受信任的应用程序，可以得到鼠标移动消息，而拖动操作可以发挥预期的作用。 
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:getDefinitionByName"><apiName>getDefinitionByName</apiName><shortdesc>
      
	  将给定的 String 转换为 Class 或数据包级的 Function。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>使用 <codeph>name</codeph> 或 null 表示的 Class。
	  
	  </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>name</apiItemName><apiType value="String"/><apiDesc>类名称，例如“mx.video.VideoManager”。
	 
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
      
	  将给定的 String 转换为 Class 或数据包级的 Function。根据是否加载到其他应用程序来调用适当的 <codeph>ApplicationDomain.getDefinition()</codeph> 方法。
	 
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:getExplicitOrMeasuredHeight"><apiName>getExplicitOrMeasuredHeight</apiName><shortdesc>
      一种可以确定是使用显式高度还是测量高度的简便方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个 Number，在已定义的情况下是 <codeph>explicitHeight</codeph> 属性，在未定义的情况下是 <codeph>measuredHeight</codeph> 属性。
      
      </apiDesc><apiType value="Number"/></apiReturn></apiOperationDef><apiDesc>
      一种可以确定是使用显式高度还是测量高度的简便方法。
           </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:getExplicitOrMeasuredWidth"><apiName>getExplicitOrMeasuredWidth</apiName><shortdesc>
      一种可以确定是使用显式宽度还是测量宽度的简便方法。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>一个 Number，在已定义的情况下是 <codeph>explicitWidth</codeph> 属性，在未定义的情况下是 <codeph>measuredWidth</codeph> 属性。
      
      </apiDesc><apiType value="Number"/></apiReturn></apiOperationDef><apiDesc>
      一种可以确定是使用显式宽度还是测量宽度的简便方法。
           </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:getSWFRoot"><apiName>getSWFRoot</apiName><shortdesc>
      返回包含给定对象的代码的 SWF 的根 DisplayObject。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>根 DisplayObject
      
      </apiDesc><apiType value="flash.display:DisplayObject"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value="Object"/><apiDesc>任一 Object。 
     
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      返回包含给定对象的代码的 SWF 的根 DisplayObject。
           </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:getSandboxRoot"><apiName>getSandboxRoot</apiName><shortdesc>
      沿父级链上行，到达此 SecurityDomain 中的顶级系统管理器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>此 SecurityDomain 中的根系统管理器。
      
      </apiDesc><apiType value="flash.display:DisplayObject"/></apiReturn></apiOperationDef><apiDesc>
      沿父级链上行，到达此 SecurityDomain 中的顶级系统管理器。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:getTopLevelRoot"><apiName>getTopLevelRoot</apiName><shortdesc>
      沿父级链上行，到达顶级系统管理器。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>根系统管理器。
      
      </apiDesc><apiType value="flash.display:DisplayObject"/></apiReturn></apiOperationDef><apiDesc>
      沿父级链上行，到达顶级系统管理器。如果我们不在显示列表上，或我们无权访问顶级系统管理器，则返回 <codeph>null</codeph>。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:getVisibleApplicationRect"><apiName>getVisibleApplicationRect</apiName><shortdesc>
     
      获取所加载的应用程序在屏幕上对用户可见的范围。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>包括此对象可见部分的 <codeph>Rectangle</codeph>。该矩形采用全局坐标。
      
      </apiDesc><apiType value="flash.geom:Rectangle"/></apiReturn><apiParam><apiItemName>bounds</apiItemName><apiType value="flash.geom:Rectangle"/><apiData>null</apiData><apiDesc>可选。可见矩形的起始边界。边界采用全局坐标。如果 <codeph>bounds</codeph> 为 null，则起始边界由系统管理器的 <codeph>screen</codeph> 属性定义。 
     
      </apiDesc></apiParam><apiParam><apiItemName>skipToSandboxRoot</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam></apiOperationDef><apiDesc>
     
      获取所加载的应用程序在屏幕上对用户可见的范围。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:invalidateParentSizeAndDisplayList"><apiName>invalidateParentSizeAndDisplayList</apiName><shortdesc>
      尝试向父 SWFLoader 通知应用程序的大小已更改。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiTool description="" name="Flex" version="4"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      尝试向父 SWFLoader 通知应用程序的大小已更改。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:isFontFaceEmbedded"><apiName>isFontFaceEmbedded</apiName><shortdesc>
      
      如果所需的字体已嵌入到此应用程序中，或已使用 Font.registerFont() 方法进行了全局注册，则返回 true。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果所需的字体已嵌入到此应用程序中，或已使用 <codeph>Font.registerFont()</codeph> 方法进行了全局注册，则返回 <codeph>true</codeph>。
      
      </apiDesc><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>textFormat</apiItemName><apiType value="flash.text:TextFormat"/><apiDesc>提供字符格式设置信息的 TextFormat 类。
	 
	  </apiDesc></apiParam></apiOperationDef><apiDesc>
      
      如果所需的字体已嵌入到此应用程序中，或已使用 <codeph>Font.registerFont()</codeph> 方法进行了全局注册，则返回 <codeph>true</codeph>。
	 
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:isTopLevelRoot"><apiName>isTopLevelRoot</apiName><shortdesc>
     
      测试此系统管理器是否为所有顶级系统管理器的根。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果此 SystemManager 是显示列表上所有 SystemManager 的根，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
      
      </apiDesc><apiType value="Boolean"/></apiReturn></apiOperationDef><apiDesc>
     
      测试此系统管理器是否为所有顶级系统管理器的根。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:isTopLevelWindow"><apiName>isTopLevelWindow</apiName><shortdesc>
          确定给定的 DisplayObject 是否为顶级窗口。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果给定的 DisplayObject 是顶级窗口，则为 <codeph>true</codeph>。
      
      </apiDesc><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>object</apiItemName><apiType value="flash.display:DisplayObject"/><apiDesc>要测试的 DisplayObject。
           </apiDesc></apiParam></apiOperationDef><apiDesc>
          确定给定的 DisplayObject 是否为顶级窗口。
           </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:isTopLevel"><apiName>isTopLevel</apiName><shortdesc>
      
	  如果此 ISystemManager 负责应用程序窗口，则返回 true；如果此应用程序已加载到其他应用程序中，则返回 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果此 ISystemManager 负责应用程序窗口，则返回 <codeph>true</codeph>。
	  
	  </apiDesc><apiType value="Boolean"/></apiReturn></apiOperationDef><apiDesc>
      
	  如果此 ISystemManager 负责应用程序窗口，则返回 <codeph>true</codeph>；如果此应用程序已加载到其他应用程序中，则返回 <codeph>false</codeph>。
	 
	  </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:move"><apiName>move</apiName><shortdesc>
      调用 move() 方法不会起任何作用，因为它会直接映射到应用程序窗口或加载器中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>x</apiItemName><apiType value="Number"/><apiDesc>新的 x 坐标。
           </apiDesc></apiParam><apiParam><apiItemName>y</apiItemName><apiType value="Number"/><apiDesc>新的 y 坐标。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      调用 <codeph>move()</codeph> 方法不会起任何作用，因为它会直接映射到应用程序窗口或加载器中。
           </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:SystemManager:setActualSize"><apiName>setActualSize</apiName><shortdesc>
      如果可以直接映射到应用程序窗口并且该窗口是顶级窗口，则调用 setActualSize() 方法不会产生任何影响。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>newWidth</apiItemName><apiType value="Number"/><apiDesc>新的宽度。
           </apiDesc></apiParam><apiParam><apiItemName>newHeight</apiItemName><apiType value="Number"/><apiDesc>新的高度。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      如果可以直接映射到应用程序窗口并且该窗口是顶级窗口，则调用 <codeph>setActualSize()</codeph> 方法不会产生任何影响。另外，请尝试让其自行调整大小，如果需要，还可以裁减子项。
           </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:SystemManager:allowDomainsInNewRSLs:get"><apiName>allowDomainsInNewRSLs</apiName><shortdesc>
      
      控制调用 allowDomain() 所允许的域是否也被调用后加载的 RSL 允许。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10.2"/><apiPlatform description="" name="AIR" version="2.6"/><apiTool description="" name="Flex" version="4.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/></apiValueDef><apiDesc>
      
      控制调用 <codeph>allowDomain()</codeph> 所允许的域是否也被调用后加载的 RSL 允许。其它 RSL 可能会由子应用程序或模块加载到此模块工厂中。
           </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:allowInsecureDomainsInNewRSLs:get"><apiName>allowInsecureDomainsInNewRSLs</apiName><shortdesc>
      
      控制调用 allowInsecureDomain() 所允许的域是否也被调用后加载的 RSL 允许。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10.2"/><apiPlatform description="" name="AIR" version="2.6"/><apiTool description="" name="Flex" version="4.5"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/></apiValueDef><apiDesc>
      
      控制调用 <codeph>allowInsecureDomain()</codeph> 所允许的域是否也被调用后加载的 RSL 允许。其它 RSL 可能会由子应用程序或模块添加至此模板工厂中。
           </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:application:get"><apiName>application</apiName><shortdesc>
      此 SystemManager 的子应用程序。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>mx.core:IUIComponent</apiValueClassifier></apiValueDef><apiDesc>
      此 SystemManager 的子应用程序。即使已将 SystemManager 加载到某个 Application 中，也可以使用它来创建其他 Application 的实例。因此，如果已将 SWF 加载到其他应用程序，则此属性就无法与 mx.core.Application.application 匹配。
      <p>请注意，出于加载时性能考虑，此属性的类型不能为 mx.core.Application，但可以将其强制为 mx.core.Application。</p>
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:childAllowsParent:get"><apiName>childAllowsParent</apiName><shortdesc>
     </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
     </apiDesc></apiValueDetail><apiInheritDoc/></apiValue><apiValue id="mx.managers:SystemManager:cursorChildren:get"><apiName>cursorChildren</apiName><shortdesc>
      
	  使用此 ISystemManager 作为父项的自定义光标的列表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>mx.core:IChildList</apiValueClassifier></apiValueDef><apiDesc>
      
	  使用此 ISystemManager 作为父项的自定义光标的列表。
	 
	  <p>ISystemManager 包含各种类型的子项，例如应用程序、弹出窗口、顶级窗口、工具提示和自定义光标。您可以通过 <codeph>cursorChildren</codeph> 属性访问自定义光标。</p>
	 
	  <p>IChildList 对象具有类似于 <codeph>getChildAt()</codeph> 的方法和类似于 <codeph>numChildren</codeph> 的属性。例如，<codeph>cursorChildren.numChildren</codeph> 可提供自定义光标数目（可以是 0，也可以是 1）；如果存在自定义光标，您可以将其当作 <codeph>cursorChildren.getChildAt(0)</codeph> 进行访问。</p>
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:document:get"><apiName>document</apiName><shortdesc>
      
	  对文档对象的引用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Object"/></apiValueDef><apiDesc>
      
	  对文档对象的引用。文档对象是位于 Flex 应用程序、MXML 组件或 AS 组件层次结构顶层的 Object。
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:embeddedFontList:get"><apiName>embeddedFontList</apiName><shortdesc>
      此应用程序中的嵌入字体表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
      此应用程序中的嵌入字体表。此对象是一个按字体名称编制索引的表格。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:explicitHeight:get"><apiName>explicitHeight</apiName><shortdesc>
      此对象的显式宽度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Number"/></apiValueDef><apiDesc>
      此对象的显式宽度。对于 SystemManager 而言，只要未将此应用程序加载到其他应用程序中，此值就应始终为 NaN。如果此应用程序未加载到其他应用程序中，则设置此值不会起任何作用。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:explicitWidth:get"><apiName>explicitWidth</apiName><shortdesc>
      此对象的显式宽度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Number"/></apiValueDef><apiDesc>
      此对象的显式宽度。对于 SystemManager 而言，只要未将此应用程序加载到其他应用程序中，此值就应始终为 NaN。如果此应用程序未加载到其他应用程序中，则设置此值不会起任何作用。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:focusPane:get"><apiName>focusPane</apiName><shortdesc conref="mx.core.UIComponent#focusPane">
      </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="flash.display:Sprite"/></apiValueDef><apiDesc conref="mx.core.UIComponent#focusPane">
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:height:get"><apiName>height</apiName><shortdesc>
      此对象的高度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Number"/></apiValueDef><apiDesc>
      此对象的高度。对于 SystemManager 而言，只要该应用程序未加载到其他应用程序中，此值就应始终为舞台的宽度。如果此应用程序未加载到其他应用程序中，则设置此值不会起任何作用。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:isProxy:get"><apiName>isProxy</apiName><shortdesc>
      如果 SystemManager 是代理而不是根类时为 true
     </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
      如果 SystemManager 是代理而不是根类时为 true
     </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:measuredHeight:get"><apiName>measuredHeight</apiName><shortdesc>
      measuredHeight 可以是主 mx.core.Application 窗口的显式高度或 measuredHeight，如果尚未创建主窗口或主窗口不存在，则可以是 SWF 的起始高度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Number"/></apiValueDef><apiDesc>
      measuredHeight 可以是主 mx.core.Application 窗口的显式高度或 measuredHeight，如果尚未创建主窗口或主窗口不存在，则可以是 SWF 的起始高度。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:measuredWidth:get"><apiName>measuredWidth</apiName><shortdesc>
      measuredWidth 可以是主 mx.core.Application 窗口的显式宽度或 measuredWidth，如果尚未创建主窗口或主窗口不存在，则可以是 SWF 的起始宽度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Number"/></apiValueDef><apiDesc>
      measuredWidth 可以是主 mx.core.Application 窗口的显式宽度或 measuredWidth，如果尚未创建主窗口或主窗口不存在，则可以是 SWF 的起始宽度。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:numChildren:get"><apiName>numChildren</apiName><shortdesc>
      非浮动窗口的数目。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="int"/></apiValueDef><apiDesc>
      非浮动窗口的数目。此值是主应用程序窗口以及添加到 SystemManager 中的除弹出窗口、工具提示或光标以外的任何其他窗口数目之和。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:numModalWindows:get"><apiName>numModalWindows</apiName><shortdesc>
      模式窗口的数量。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="int"/></apiValueDef><apiDesc>
      模式窗口的数量。模式窗口不允许在其他窗口中单击，因为这通常会激活该窗口中的 FocusManager。PopUpManager 在创建和销毁模式窗口时会修改此计数。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:parentAllowsChild:get"><apiName>parentAllowsChild</apiName><shortdesc conref="mx.core.ISWFBridgeProvider#parentAllowsChild">
      </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc conref="mx.core.ISWFBridgeProvider#parentAllowsChild">
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:parent:get"><apiName>parent</apiName><shortdesc>
     覆盖 parent 属性，用于处理父级位于不同沙箱中的情况。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="flash.display:DisplayObjectContainer"/></apiValueDef><apiDesc>
     覆盖 parent 属性，用于处理父级位于不同沙箱中的情况。如果父级位于同一沙箱中，则返回父级。如果父级位于不同的沙箱中，则返回 null。
     
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:popUpChildren:get"><apiName>popUpChildren</apiName><shortdesc>
      
	  将使用此 ISystemManager 作为父项的最顶级窗口（弹出窗口）的列表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>mx.core:IChildList</apiValueClassifier></apiValueDef><apiDesc>
      
	  将使用此 ISystemManager 作为父项的最顶级窗口（弹出窗口）的列表。
	 
	  <p>ISystemManager 包含各种类型的子项，例如应用程序、弹出窗口、工具提示和自定义光标。您可以通过 <codeph>popUpChildren</codeph> 属性访问最顶级窗口。</p>
	 
	  <p>IChildList 对象具有类似于 <codeph>getChildAt()</codeph> 的方法和类似于 <codeph>numChildren</codeph> 的属性。例如，<codeph>popUpChildren.numChildren</codeph> 可提供最顶部窗口的数量，您可将最顶部窗口当作 <codeph>popUpChildren.getChildAt(i)</codeph> 进行访问。</p>
	 
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:preloadedRSLs:get"><apiName>preloadedRSLs</apiName><shortdesc>
      
      启动应用程序之前该 SystemManager 或 FlexModuleFactory 加载的 RSL。</shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="flash.utils:Dictionary"/></apiValueDef><apiDesc>
      
      启动应用程序之前该 SystemManager 或 FlexModuleFactory 加载的 RSL。该字典中可能还包含被其它模块或子应用程序加载到该模块工厂的应用程序域中的 RSL。子模块工厂添加新的字典条目时，拥有该字典的模块工厂将分派 <codeph>RSLEvent.RSL_ADD_PRELOADED</codeph> 事件。预加载的 RSL 信息存储在词典中。该键为 RSL 的 LoaderInfo。该值为 RSLData 的矢量，其中第一个元素是主 RSL，其余元素为故障转移 RSL。
           </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:preloaderBackgroundAlpha:get"><apiName>preloaderBackgroundAlpha</apiName><shortdesc>
      preloader 的子项使用的背景 Alpha。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Number"/></apiValueDef><apiDesc>
      preloader 的子项使用的背景 Alpha。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:preloaderBackgroundColor:get"><apiName>preloaderBackgroundColor</apiName><shortdesc>
      preloader 的子项使用的背景颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="uint"/></apiValueDef><apiDesc>
      preloader 的子项使用的背景颜色。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:preloaderBackgroundImage:get"><apiName>preloaderBackgroundImage</apiName><shortdesc>
      preloader 的子项使用的背景颜色。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
      preloader 的子项使用的背景颜色。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:preloaderBackgroundSize:get"><apiName>preloaderBackgroundSize</apiName><shortdesc>
      preloader 的子项使用的背景大小。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="String"/></apiValueDef><apiDesc>
      preloader 的子项使用的背景大小。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:rawChildren:get"><apiName>rawChildren</apiName><shortdesc>
      
	  使用此 ISystemManager 作为父项的所有子项的列表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>mx.core:IChildList</apiValueClassifier></apiValueDef><apiDesc>
      
	  使用此 ISystemManager 作为父项的所有子项的列表。
	 
	  <p>ISystemManager 包含各种类型的子项，例如应用程序、弹出窗口、工具提示和自定义光标。</p>
	 
	  <p>IChildList 对象具有类似于 <codeph>getChildAt()</codeph> 的方法和类似于 <codeph>numChildren</codeph> 的属性。</p>
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:screen:get"><apiName>screen</apiName><shortdesc>
      
	  应用程序窗口的大小和位置。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="flash.geom:Rectangle"/></apiValueDef><apiDesc>
      
	  应用程序窗口的大小和位置。Rectangle 对象包含 <codeph>x</codeph>、<codeph>y</codeph>、<codeph>width</codeph> 和 <codeph>height</codeph> 属性。矩形位于沙箱根坐标中。
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:toolTipChildren:get"><apiName>toolTipChildren</apiName><shortdesc>
      
	  将使用此 ISystemManager 作为父项的工具提示的列表。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>mx.core:IChildList</apiValueClassifier></apiValueDef><apiDesc>
      
	  将使用此 ISystemManager 作为父项的工具提示的列表。
	 
	  <p>ISystemManager 包含各种类型的子项，例如应用程序、弹出窗口、最顶部窗口、工具提示和自定义光标。</p>
	 
	  <p>IChildList 对象具有类似于 <codeph>getChildAt()</codeph> 的方法和类似于 <codeph>numChildren</codeph> 的属性。例如，<codeph>toolTipChildren.numChildren</codeph> 可提供工具提示数目（可以是 0，也可以是 1）；如果存在工具提示，您可以将其当作 <codeph>toolTipChildren.getChildAt(0)</codeph> 进行访问。</p>
	  
	  </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:topLevelSystemManager:get"><apiName>topLevelSystemManager</apiName><shortdesc>
      返回负责应用程序窗口的 SystemManager。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>mx.managers:ISystemManager</apiValueClassifier></apiValueDef><apiDesc>
      返回负责应用程序窗口的 SystemManager。只要此应用程序尚未加载到其他应用程序中，这就是同一个 SystemManager。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:SystemManager:width:get"><apiName>width</apiName><shortdesc>
      此对象的宽度。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Number"/></apiValueDef><apiDesc>
      此对象的宽度。对于 SystemManager 而言，只要该应用程序未加载到其他应用程序中，此值就应始终为舞台的宽度。如果此应用程序未加载到其它应用程序中，则设置此值不会起任何作用。
      
      </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:LayoutManager"><apiName>LayoutManager</apiName><shortdesc>
  LayoutManager 是 Flex 的度量和布局策略所基于的引擎。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>mx.managers:ILayoutManager</apiBaseInterface><apiBaseClassifier>flash.events:EventDispatcher</apiBaseClassifier></apiClassifierDef><apiDesc>
  LayoutManager 是 Flex 的度量和布局策略所基于的引擎。布局分三个阶段执行：提交、度量和布局。
 
  <p>这三个阶段互不相同，并且，只有在处理完当前阶段的所有 UIComponent 之后才会进入下一阶段。在某个阶段中处理 UIComponent 期间，可能出现另一阶段请求重新处理 UIComponent 的情况。这些请求将进行排队，并且只在下次运行此阶段时才得到处理。</p>
 
  <p><b>提交</b>阶段从调用 <codeph>validateProperties()</codeph> 开始，该方法将遍历一个对象列表（该列表按嵌套级别反向排序），并调用每个对象的 <xref href="../core/UIComponent.html#validateProperties()"><codeph>validateProperties()</codeph></xref> 方法。</p>
 
  <p>列表中的对象是按与嵌套级别正相反的顺序接受处理的，所以最先访问的是嵌套深度<b>最浅</b>的对象。这也可以称为自上而下或从外到内的顺序。</p>
 
  <p>在此阶段中，允许内容依据属性设置而定的组件在进入度量和布局阶段之前进行自我配置。为了获得更好的性能，组件的属性 setter 方法有时不执行更新到新属性值所需的全部操作。但是，属性 setter 会调用 <codeph>invalidateProperties()</codeph> 方法，并在运行此阶段之前延迟此操作。这样，可以在多次设置属性时避免执行不必要的操作。</p>
 
  <p><b>度量</b>阶段从调用 <codeph>validateSize()</codeph> 开始，该方法将遍历一个对象列表（该列表按嵌套级别排序），并调用每个对象的 <xref href="../core/UIComponent.html#validateSize()"><codeph>validateSize()</codeph></xref> 方法，以确定对象大小是否已更改。</p>
 
  <p>如果之前调用过对象的 <xref href="../core/UIComponent.html#invalidateSize()"> <codeph>invalidateSize()</codeph></xref> 方法，则调用 <codeph>validateSize()</codeph> 方法。如果对象的大小或位置因调用 <codeph>validateSize()</codeph> 而发生了更改，则会调用对象的 <xref href="../core/UIComponent.html#invalidateDisplayList()"> <codeph>invalidateDisplayList()</codeph></xref> 方法，这就会将该对象添加到处理队列中，等待下次运行布局阶段时进行处理。此外，已分别调用 <xref href="../core/UIComponent.html#invalidateSize()"> <codeph>invalidateSize()</codeph></xref> 和 <xref href="../core/UIComponent.html#invalidateDisplayList()"> <codeph>invalidateDisplayList()</codeph></xref> 为度量和布局这两个阶段标记了对象的父项。</p>
 
  <p>列表中的对象是按嵌套级别的顺序进行处理的，所以最先访问的是嵌套深度<b>最深</b>的对象。这也可以称为自下而上或从内到外的顺序。</p>
 
  <p><b>布局</b>阶段从调用 <codeph>validateDisplayList()</codeph> 方法开始，该方法将遍历一个对象列表（该列表按嵌套级别反向排序），并调用每个对象的 <xref href="../core/UIComponent.html#validateDisplayList()"><codeph>validateDisplayList()</codeph></xref> 方法，以请求对象确定它所包含的所有组件（即其子对象）的大小和位置。</p>
 
  <p>	如果之前调用过对象的 <xref href="../core/UIComponent.html#invalidateDisplayList()"> <codeph>invalidateDisplayList()</codeph></xref> 方法，则调用 <codeph>validateDisplayList()</codeph> 方法。</p>
 
  <p>列表中的对象是按与嵌套级别正相反的顺序接受处理的，所以最先访问的是嵌套深度<b>最浅</b>的对象。这也可以称为自上而下或从外到内的顺序。</p>
 
  <p>通常情况下，组件不会覆盖 <codeph>validateProperties()</codeph>、<codeph>validateSize()</codeph> 或 <codeph>validateDisplayList()</codeph> 方法。对于 UIComponent 而言，大部分组件都会覆盖分别由 <codeph>validateProperties()</codeph>、<codeph>validateSize()</codeph> 或 <codeph>validateDisplayList()</codeph> 方法调用的 <codeph>commitProperties()</codeph>、<codeph>measure()</codeph> 或 <codeph>updateDisplayList()</codeph> 方法。</p>
 
  <p>当应用程序启动时，将创建一个 LayoutManager 实例并将其存储在 <codeph>UIComponent.layoutManager</codeph> 属性中。所有组件都应使用此实例。如果您无权访问 UIComponent 对象，也可以使用静态 <codeph>LayoutManager.getInstance()</codeph> 方法访问 LayoutManager。</p>
  
  </apiDesc></apiClassifierDetail><apiOperation id="mx.managers:LayoutManager:attachListeners"><apiName>attachListeners</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>systemManager</apiItemName><apiOperationClassifier>mx.managers:ISystemManager</apiOperationClassifier></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="mx.managers:LayoutManager:getInstance"><apiName>getInstance</apiName><shortdesc>
      返回此 singleton 类的唯一实例；如果不存在这样的实例，则创建一个。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>返回此 singleton 类的唯一实例；如果不存在这样的实例，则创建一个。
          
          </apiDesc><apiOperationClassifier>mx.managers:LayoutManager</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
      返回此 singleton 类的唯一实例；如果不存在这样的实例，则创建一个。
         
          </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:LayoutManager:invalidateDisplayList"><apiName>invalidateDisplayList</apiName><shortdesc>
      当组件发生的更改导致其布局和/或视觉效果需要更改时调用。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>mx.managers:ILayoutManagerClient</apiOperationClassifier><apiDesc>更改过的对象。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      当组件发生的更改导致其布局和/或视觉效果需要更改时调用。在这种情况下，即使没有更改过组件的大小，也必须运行组件的布局算法。例如，当添加了新的子组件时、样式属性发生更改时或组件的父项为组件赋予了新尺寸时。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:LayoutManager:invalidateProperties"><apiName>invalidateProperties</apiName><shortdesc>
      向希望调用其 validateProperties() 方法的组件的列表中添加一个对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>mx.managers:ILayoutManagerClient</apiOperationClassifier><apiDesc>属性已发生更改的对象。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      向希望调用其 <codeph>validateProperties()</codeph> 方法的组件的列表中添加一个对象。组件应在属性发生更改时调用此方法。通常，属性 setter 方法将新值存储在临时变量中，然后调用 <codeph>invalidateProperties()</codeph> 方法，以便稍后在新值实际应用到组件和/或其子项时调用其 <codeph>validateProperties()</codeph> 和 <codeph>commitProperties()</codeph> 方法。此策略非常适用于以下经常遇到的情况：一次更改多个属性，并且这些属性之间可能会交互；在应用代码时需重复某些代码或需要按一定顺序应用代码。此策略可以为应用新属性值提供最有效的方法。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:LayoutManager:invalidateSize"><apiName>invalidateSize</apiName><shortdesc>
      向希望调用其 validateSize() 方法的组件的列表中添加一个对象。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>obj</apiItemName><apiOperationClassifier>mx.managers:ILayoutManagerClient</apiOperationClassifier><apiDesc>大小已发生更改的对象。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      向希望调用其 <codeph>validateSize()</codeph> 方法的组件的列表中添加一个对象。当对象的大小发生更改时调用。
     
      <p>导致对象大小发生更改的原因有两个：</p>
     
      <ol>
        <li>对象的内容发生更改。例如，在更改按钮的 <codeph>label</codeph> 时更改了此按钮的大小。</li>
        <li>脚本可显式更改下列属性之一：<codeph>minWidth</codeph>、<codeph>minHeight</codeph>、<codeph>explicitWidth</codeph>、<codeph>explicitHeight</codeph>、<codeph>maxWidth</codeph> 或 <codeph>maxHeight</codeph>。</li>
      </ol>
     
      <p>发生第一种情况时，必须重新计算对象的测量值。发生第二种情况时，则不必重新计算测量值，因为对象的新尺寸是已知的。但是，必须重新测量和重新布局对象的父项。</p>
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:LayoutManager:isInvalid"><apiName>isInvalid</apiName><shortdesc>
      如果存在需要验证的组件，则返回 true；如果已经验证所有组件，则返回 false。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果存在需要验证的组件，则返回 <codeph>true</codeph>；如果已经验证所有组件，则返回 <codeph>false</codeph>。
      
      </apiDesc><apiType value="Boolean"/></apiReturn></apiOperationDef><apiDesc>
      如果存在需要验证的组件，则返回 <codeph>true</codeph>；如果已经验证所有组件，则返回 <codeph>false</codeph>。
         
          </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:LayoutManager:validateClient"><apiName>validateClient</apiName><shortdesc>
      当属性发生更改后，组件通常不会立即应用这些更改，</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>target</apiItemName><apiOperationClassifier>mx.managers:ILayoutManagerClient</apiOperationClassifier><apiDesc>传入的组件用于测试应该验证哪些组件。将调用此组件中包含的所有组件的 <codeph>validateProperties()</codeph>、<codeph>commitProperties()</codeph>、<codeph>validateSize()</codeph>、<codeph>measure()</codeph>、<codeph>validateDisplayList()</codeph> 和 <codeph>updateDisplayList()</codeph> 方法。
     
        </apiDesc></apiParam><apiParam><apiItemName>skipDisplayList</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>如果为 <codeph>true</codeph>，则不调用 <codeph>validateDisplayList()</codeph> 和 <codeph>updateDisplayList()</codeph> 方法。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      当属性发生更改后，组件通常不会立即应用这些更改，而是会调用 LayoutManager 的一个 invalidate 方法，并在稍后应用这些属性。可以立即重新读取实际设置的属性，但如果该属性会影响组件或者其子项或父项中的其他属性，则可能不会立即更新这些受影响的属性。  
     
      <p>要保证已更新这些值，可以调用 <codeph>validateClient()</codeph> 方法。它会在返回之前更新嵌套级别大于或等于目标组件的所有组件中的所有属性。仅在必要时才调用此方法，因为调用此方法需要进行大量计算。</p>
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:LayoutManager:validateNow"><apiName>validateNow</apiName><shortdesc>
      当属性发生更改后，组件通常不会立即应用这些更改，</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      当属性发生更改后，组件通常不会立即应用这些更改，而是会调用 LayoutManager 的一个 invalidate 方法，并在稍后应用这些属性。可以立即重新读取实际设置的属性，但如果该属性会影响组件或者其子项或父项中的其他属性，则可能不会立即更新这些受影响的属性。要保证已更新这些值，可以调用 <codeph>validateNow()</codeph> 方法。它会在返回之前更新所有组件中的所有属性。仅在必要时才调用此方法，因为调用此方法需要进行大量计算。
      
      </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:LayoutManager:usePhasedInstantiation:get"><apiName>usePhasedInstantiation</apiName><shortdesc>
      一个标志，用于指示 LayoutManager 是否允许在各个阶段之间更新屏幕。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/></apiValueDef><apiDesc>
      一个标志，用于指示 LayoutManager 是否允许在各个阶段之间更新屏幕。如果为 <codeph>true</codeph>，则在各阶段都会进行度量和布局，每个阶段结束后都会更新一次屏幕。所有组件都将调用其 <codeph>validateProperties()</codeph> 和 <codeph>commitProperties()</codeph> 方法，直到验证完各自的所有属性。屏幕将随之更新。  
     
      <p>然后，所有组件都将调用其 <codeph>validateSize()</codeph> 和 <codeph>measure()</codeph> 方法，直到测量完所有组件，屏幕也将再次更新。  </p>
     
      <p>最后，所有组件都将调用其 <codeph>validateDisplayList()</codeph> 和 <codeph>updateDisplayList()</codeph> 方法，直到验证完所有组件，屏幕也将再次更新。如果正在验证某个阶段，并且前面的阶段失效，则会重新启动 LayoutManager。当创建和初始化大量组件时，此方法更为高效。框架负责设置此属性。</p>
     
      <p>如果为 <codeph>false</codeph>，则会在更新屏幕之前完成所有这三个阶段。</p>
      
      </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:IMarshalSystemManager"><apiName>IMarshalSystemManager</apiName><shortdesc>
  如果类需要在交叉版本的配置中访问、添加和删除针对其它应用程序的桥，则 IMarshalSystemManager 接口定义这些类必须实现的方法和属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiTool description="" name="Flex" version="4"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
  如果类需要在交叉版本的配置中访问、添加和删除针对其它应用程序的桥，则 IMarshalSystemManager 接口定义这些类必须实现的方法和属性。
 
  </apiDesc></apiClassifierDetail><apiOperation id="mx.managers:IMarshalSystemManager:mx.managers:IMarshalSystemManager:addChildBridge"><apiName>addChildBridge</apiName><shortdesc> 
      向系统管理器添加子桥。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiTool description="" name="Flex" version="4"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bridge</apiItemName><apiType value="flash.events:IEventDispatcher"/><apiDesc>子级的桥。
     
      </apiDesc></apiParam><apiParam><apiItemName>owner</apiItemName><apiType value="flash.display:DisplayObject"/><apiDesc>子级的 SWFLoader。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc> 
      向系统管理器添加子桥。每个子桥都代表另一个沙箱中的组件，或以 Flex 的不同版本编译的组件。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IMarshalSystemManager:mx.managers:IMarshalSystemManager:addChildToSandboxRoot"><apiName>addChildToSandboxRoot</apiName><shortdesc> 
      向所请求的层中的沙箱根添加指定的子级。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiTool description="" name="Flex" version="4"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>layer</apiItemName><apiType value="String"/><apiDesc>SystemManager 中 IChildList 的名称。
     
      </apiDesc></apiParam><apiParam><apiItemName>child</apiItemName><apiType value="flash.display:DisplayObject"/><apiDesc>要添加的 DisplayObject。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc> 
      向所请求的层中的沙箱根添加指定的子级。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IMarshalSystemManager:mx.managers:IMarshalSystemManager:dispatchEventFromSWFBridges"><apiName>dispatchEventFromSWFBridges</apiName><shortdesc>
      向此 SystemManager 的 SWF 桥组中的所有父应用程序和子应用程序分派消息，无论这些应用程序是否在同一个 SecurityDomain 中都是如此。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiTool description="" name="Flex" version="4"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>event</apiItemName><apiType value="flash.events:Event"/><apiDesc>要分派的事件。
          
          </apiDesc></apiParam><apiParam><apiItemName>skip</apiItemName><apiType value="flash.events:IEventDispatcher"/><apiData>null</apiData><apiDesc>指定不想向其分派消息的 IEventDispatcher。通常用于跳过发起事件的 IEventDispatcher。
     
          </apiDesc></apiParam><apiParam><apiItemName>trackClones</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>分派事件时，是否保留对这些事件的引用。
          
          </apiDesc></apiParam><apiParam><apiItemName>toOtherSystemManagers</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>是否向 AIR 中的其他顶级 SystemManager 分派事件。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      向此 SystemManager 的 SWF 桥组中的所有父应用程序和子应用程序分派消息，无论这些应用程序是否在同一个 SecurityDomain 中都是如此。根据需要，可以用此方法的参数排除应用程序。
     
          </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IMarshalSystemManager:mx.managers:IMarshalSystemManager:isDisplayObjectInABridgedApplication"><apiName>isDisplayObjectInABridgedApplication</apiName><shortdesc>
      测试显示对象是否位于以兼容模式加载的子应用程序中，或者位于不受信任的沙箱中。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiTool description="" name="Flex" version="4"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果 <codeph>displayObject</codeph> 位于以兼容模式加载的子应用程序中，或位于不受信任的沙箱中，则为 <codeph>true</codeph>；否则为 <codeph>false</codeph>。
     
      </apiDesc><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>displayObject</apiItemName><apiType value="flash.display:DisplayObject"/><apiDesc>要测试的 DisplayObject。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      测试显示对象是否位于以兼容模式加载的子应用程序中，或者位于不受信任的沙箱中。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IMarshalSystemManager:mx.managers:IMarshalSystemManager:removeChildBridge"><apiName>removeChildBridge</apiName><shortdesc> 
      向系统管理器添加子桥。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiTool description="" name="Flex" version="4"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>bridge</apiItemName><apiType value="flash.events:IEventDispatcher"/><apiDesc>子级的桥。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc> 
      向系统管理器添加子桥。每个子桥都代表另一个沙箱中的组件，或以 Flex 的不同版本编译的组件。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IMarshalSystemManager:mx.managers:IMarshalSystemManager:removeChildFromSandboxRoot"><apiName>removeChildFromSandboxRoot</apiName><shortdesc> 
      从所请求的层中的沙箱根删除指定的子级。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiTool description="" name="Flex" version="4"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>layer</apiItemName><apiType value="String"/><apiDesc>SystemManager 中 IChildList 的名称。
     
      </apiDesc></apiParam><apiParam><apiItemName>child</apiItemName><apiType value="flash.display:DisplayObject"/><apiDesc>要添加的 DisplayObject。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc> 
      从所请求的层中的沙箱根删除指定的子级。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:IMarshalSystemManager:mx.managers:IMarshalSystemManager:useSWFBridge"><apiName>useSWFBridge</apiName><shortdesc>
      确定使用此系统管理器的调用方是应直接与其他管理器通信，还是应与桥通信。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiTool description="" name="Flex" version="4"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>如果使用此系统管理器的调用方应该使用沙箱桥进行通信，则为 <codeph>true</codeph>。如果系统管理器可以通过引用直接调用其他管理器，则为 <codeph>false</codeph>。
     
      </apiDesc><apiType value="Boolean"/></apiReturn></apiOperationDef><apiDesc>
      确定使用此系统管理器的调用方是应直接与其他管理器通信，还是应与桥通信。
     
      </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:IMarshalSystemManager:mx.managers:IMarshalSystemManager:swfBridgeGroup:get"><apiName>swfBridgeGroup</apiName><shortdesc>
      包含所有通向此应用程序所连接的其他应用程序的桥。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="10"/><apiPlatform description="" name="AIR" version="1.5"/><apiTool description="" name="Flex" version="4"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiValueClassifier>mx.core:ISWFBridgeGroup</apiValueClassifier></apiValueDef><apiDesc>
      包含所有通向此应用程序所连接的其他应用程序的桥。
     
      </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:ILayoutManagerClient"><apiName>ILayoutManagerClient</apiName><shortdesc>
  ILayoutManagerClient 接口用于定义一类接口，组件必须实现此类接口才能加入 LayoutManager 的提交/度量/布局序列。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>flash.events:IEventDispatcher</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
  ILayoutManagerClient 接口用于定义一类接口，组件必须实现此类接口才能加入 LayoutManager 的提交/度量/布局序列。  
 
  <p>可将实现此接口的对象传递给 LayoutManager 的 <codeph>invalidateProperties()</codeph> 方法。当 LayoutManager 达到提交属性阶段时，LayoutManager 将调用此对象的 <codeph>validateProperties()</codeph> 方法。</p>
 
  <p>同样，如果将某个对象传递给 LayoutManager 的 <codeph>invalidateSize()</codeph> 方法，则 LayoutManager 随后将在度量阶段调用该对象的 <codeph>validateSize()</codeph> 方法；如果将某个对象传递到 LayoutManager 的 <codeph>invalidateDisplayList()</codeph> 方法，则 LayoutManager 随后将在布局阶段调用其 <codeph>validateDisplayList()</codeph> 方法。</p>
 
  <p>ILayoutManagerClient 接口由 UIComponent 类和 ProgrammaticSkin 类实现。</p>
  
  </apiDesc></apiClassifierDetail><apiOperation id="mx.managers:ILayoutManagerClient:mx.managers:ILayoutManagerClient:validateDisplayList"><apiName>validateDisplayList</apiName><shortdesc>
      验证子项的位置和大小，并绘制其他可视内容。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      验证子项的位置和大小，并绘制其他可视内容。如果使用此 ILayoutManagerClient 调用 <codeph>LayoutManager.invalidateDisplayList()</codeph> 方法，则当更新显示列表时会调用 <codeph>validateDisplayList()</codeph> 方法。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ILayoutManagerClient:mx.managers:ILayoutManagerClient:validateProperties"><apiName>validateProperties</apiName><shortdesc>
      验证组件的属性。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      验证组件的属性。如果使用此 ILayoutManagerClient 调用 <codeph>LayoutManager.invalidateProperties()</codeph> 方法，则当提交属性值时会调用 <codeph>validateProperties()</codeph> 方法。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:ILayoutManagerClient:mx.managers:ILayoutManagerClient:validateSize"><apiName>validateSize</apiName><shortdesc>
      如果使用此 ILayoutManagerClient 调用 LayoutManager.invalidateSize() 方法，随后在测量时调用了 validateSize() 方法，则验证组件的度量大小。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>recursive</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>如果为 <codeph>true</codeph>，则调用对象子项的此方法。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      如果使用此 ILayoutManagerClient 调用 <codeph>LayoutManager.invalidateSize()</codeph> 方法，随后在测量时调用了 <codeph>validateSize()</codeph> 方法，则验证组件的度量大小。
     
      </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:ILayoutManagerClient:mx.managers:ILayoutManagerClient:initialized:get"><apiName>initialized</apiName><shortdesc>
      一个标志，用于确定某个对象是否已完全通过了布局验证的三个阶段（假设每一阶段都是必需的）。此标志应只能由 LayoutManager 修改。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/></apiValueDef><apiDesc>
      一个标志，用于确定某个对象是否已完全通过了布局验证的三个阶段（假设每一阶段都是必需的）。此标志应只能由 LayoutManager 修改。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ILayoutManagerClient:mx.managers:ILayoutManagerClient:nestLevel:get"><apiName>nestLevel</apiName><shortdesc>
      顶级 SystemManager 的 nestLevel 为 1。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="int"/></apiValueDef><apiDesc>
      顶级 SystemManager 的 nestLevel 为 1。其直接子项（顶级应用程序及所有弹出窗口）的 <codeph>nestLevel</codeph> 为 2。这些直接子项的子项的 <codeph>nestLevel</codeph> 为 3，依此类推。<codeph>nestLevel</codeph> 用于在度量和布局阶段对 ILayoutManagerClient 进行排序。在提交阶段，LayoutManager 按 <codeph>nestLevel</codeph> 递增的顺序提交客户端属性，这样，在 Flex 提交对象本身的属性前，该对象的子项的属性已提交。在度量阶段，LayoutManager 按 <codeph>nestLevel</codeph> 递减的顺序测量客户端，这样，在 Flex 测量对象本身前，该对象的子项即已完成测量。在布局阶段，LayoutManager 按 <codeph>nestLevel</codeph> 递减的顺序布局客户端，这样，在要求对象定位其子项并设置子项大小前，该对象的父项还可以设置其大小。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ILayoutManagerClient:mx.managers:ILayoutManagerClient:processedDescriptors:get"><apiName>processedDescriptors</apiName><shortdesc conref="mx.core.UIComponent#processedDescriptors">
      </shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/></apiValueDef><apiDesc conref="mx.core.UIComponent#processedDescriptors">
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:ILayoutManagerClient:mx.managers:ILayoutManagerClient:updateCompletePendingFlag:get"><apiName>updateCompletePendingFlag</apiName><shortdesc>
      一个标志，用于确定某个对象是否正在等待分派其 updateComplete 事件。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Boolean"/></apiValueDef><apiDesc>
      一个标志，用于确定某个对象是否正在等待分派其 <codeph>updateComplete</codeph> 事件。此标志只能由 LayoutManager 修改。
      
      </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:IToolTipManagerClient"><apiName>IToolTipManagerClient</apiName><shortdesc>
  实现 IToolTipManagerClient 的组件可以包含多个工具提示，而且必须包含工具提示 getter/setter。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>mx.core:IFlexDisplayObject</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
  实现 IToolTipManagerClient 的组件可以包含多个工具提示，而且必须包含工具提示 getter/setter。ToolTipManager 类可以代表任何作为 IToolTipManagerClient 的组件管理工具提示的显示和隐藏。
 
  </apiDesc></apiClassifierDetail><related-links><link href="mx.controls.xml#ToolTip"><linktext>mx.controls.ToolTip</linktext></link><link href="mx.managers.xml#ToolTipManager"><linktext>mx.managers.ToolTipManager</linktext></link><link href="mx.core.xml#IToolTip"><linktext>mx.core.IToolTip</linktext></link></related-links><apiValue id="mx.managers:IToolTipManagerClient:mx.managers:IToolTipManagerClient:toolTip:get"><apiName>toolTip</apiName><shortdesc>
	  此组件的工具提示文本。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="String"/></apiValueDef><apiDesc>
	  此组件的工具提示文本。
	  
	  </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="mx.managers:CursorManager"><apiName>CursorManager</apiName><shortdesc>
  CursorManager 类控制光标的优先级列表，在该列表中，具有最高优先级的光标是当前可见的光标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion><styles><style inherit="no" name="busyCursorBackground" owner="mx.managers:CursorManager" playerVersion="Flash9" type="Class">
<description>
  用作忙状态光标背景外观的类。默认值为 Assets.swf 文件中的“cursorStretch”元件。
  
  </description>

<playerversion>AIR 1.1
  </playerversion>
	<prolog><asCustoms><langversion>3.0
  </langversion><productversion>Flex 3
 </productversion></asCustoms></prolog></style><style inherit="no" name="busyCursor" owner="mx.managers:CursorManager" playerVersion="Flash9" type="Class">
<description>
  忙状态光标的外观。
 
  </description>
<default>mx.skins.halo.BusyCursor
  
  </default>

<playerversion>AIR 1.1
  </playerversion>
	<prolog><asCustoms><langversion>3.0
  </langversion><productversion>Flex 3
 </productversion></asCustoms></prolog></style></styles></asMetadata></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
  CursorManager 类控制光标的优先级列表，在该列表中，具有最高优先级的光标是当前可见的光标。如果光标列表中有多个光标具有同一优先级，则光标管理器将显示最近创建的光标。
  
  <p>例如，如果应用程序正在执行的处理过程要求用户等待处理完成，则可以对光标进行更改，使其反映等待期。在这种情况下，您可以将光标更改为沙漏或其他图像。</p>
  
  <p>您可能还希望将光标更改为可以向用户提供反馈，用来指示用户可以执行的操作。例如，您可以使用一个光标图像来指示已启用用户输入，使用另一个光标图像来指示已禁用用户输入。您可以使用 JPEG、GIF、PNG 或 SVG 图像、Sprite 对象或者 SWF 文件来作为光标图像。</p>
  
  <p>CursorManager 的所有方法和属性都是静态的，因此不需要为其创建实例。</p>
 
  <p>在 AIR 中，每个 mx.core.Window 实例都使用自己的 CursorManager 类的实例。不直接引用 CursorManager 类的静态方法和属性，而是使用 <codeph>Window.cursorManager</codeph> 属性引用 Window 实例的 CursorManager 实例。 </p>
 
  </apiDesc></apiClassifierDetail><related-links><link href="mx.managers.xml#CursorManagerPriority"><linktext>mx.managers.CursorManagerPriority</linktext></link><link href="" invalidHref="mx.core.Window.xml"><linktext>mx.core.Window</linktext></link></related-links><apiOperation id="mx.managers:CursorManager:getInstance"><apiName>getInstance</apiName><shortdesc>
      AIR 应用程序中的每个 mx.core.Window 实例都有自己的 CursorManager 实例。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>AIR 应用程序中主 Window 实例的 CursorManager 实例。  
      
      </apiDesc><apiType value="mx.managers:ICursorManager"/></apiReturn></apiOperationDef><apiDesc>
      AIR 应用程序中的每个 mx.core.Window 实例都有自己的 CursorManager 实例。此方法将返回主 Window 实例的 CursorManager 实例。  
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:CursorManager:hideCursor"><apiName>hideCursor</apiName><shortdesc>
      使光标不可见。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      使光标不可见。无法对光标可见性进行引用计数。无论调用了多少次 <codeph>showCursor()</codeph> 方法，只要调用一次 <codeph>hideCursor()</codeph> 方法就会始终隐藏光标。
     
      <p>调用此方法不会影响系统光标。使用 <codeph>Mouse.show()</codeph> 和 <codeph>Mouse.hide()</codeph> 方法可直接控制系统光标。 </p>
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:CursorManager:removeAllCursors"><apiName>removeAllCursors</apiName><shortdesc>
      删除光标列表中的所有光标并存储系统光标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      删除光标列表中的所有光标并存储系统光标。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:CursorManager:removeBusyCursor"><apiName>removeBusyCursor</apiName><shortdesc>
      从光标列表中删除忙状态光标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      从光标列表中删除忙状态光标。如果光标列表中还有其他忙状态光标请求处于活动状态，也就是说您已多次调用 <codeph>setBusyCursor()</codeph> 方法，那么，只有从列表中删除了所有忙状态光标后，忙状态光标才会消失。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:CursorManager:removeCursor"><apiName>removeCursor</apiName><shortdesc>
      从光标列表中删除光标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>cursorID</apiItemName><apiType value="int"/><apiDesc>要删除的光标的 ID。
      
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      从光标列表中删除光标。如果要删除的光标是当前显示的光标，则 CursorManager 会显示列表中的下一个光标（如果存在）。如果列表已经为空，则 CursorManager 将显示默认的系统光标。
     
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:CursorManager:setBusyCursor"><apiName>setBusyCursor</apiName><shortdesc>
      显示忙状态光标。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      显示忙状态光标。忙状态光标的优先级是 CursorManagerPriority.LOW。因此，只要光标列表中包含具有更高优先级的光标，就不会显示忙状态光标，直到删除了更高优先级的光标。要创建一个具有较高优先级的忙状态光标，可使用 <codeph>setCursor()</codeph> 方法。
      
      </apiDesc></apiOperationDetail></apiOperation><apiOperation id="mx.managers:CursorManager:setCursor"><apiName>setCursor</apiName><shortdesc>
      创建新光标并为此光标设置可选优先级。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>光标的 ID。
     
      </apiDesc><apiType value="int"/></apiReturn><apiParam><apiItemName>cursorClass</apiItemName><apiType value="Class"/><apiDesc>要显示的光标的类。
     
      </apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiType value="int"/><apiData>2</apiData><apiDesc>用于指定光标优先级的整数。可能的值为 <codeph>CursorManagerPriority.HIGH</codeph>、<codeph>CursorManagerPriority.MEDIUM</codeph> 和 <codeph>CursorManagerPriority.LOW</codeph>。
     
      </apiDesc></apiParam><apiParam><apiItemName>xOffset</apiItemName><apiType value="Number"/><apiData>0</apiData><apiDesc>用于指定光标随鼠标指针变化的 x 偏移（以像素为单位）的数字。
     
      </apiDesc></apiParam><apiParam><apiItemName>yOffset</apiItemName><apiType value="Number"/><apiData>0</apiData><apiDesc>用于指定光标随鼠标指针变化的 y 偏移（以像素为单位）的数字。
     
      </apiDesc></apiParam></apiOperationDef><apiDesc>
      创建新光标并为此光标设置可选优先级。向光标列表添加新的光标。
     
      </apiDesc></apiOperationDetail><related-links><link href="mx.managers.xml#CursorManagerPriority"><linktext>mx.managers.CursorManagerPriority</linktext></link></related-links></apiOperation><apiOperation id="mx.managers:CursorManager:showCursor"><apiName>showCursor</apiName><shortdesc>
      使光标可见。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
      使光标可见。无法对光标可见性进行引用计数。无论调用了多少次 <codeph>hideCursor()</codeph> 方法，只要调用一次 <codeph>showCursor()</codeph> 方法就会始终显示光标。
     
      <p>调用此方法不会影响系统光标。使用 <codeph>Mouse.show()</codeph> 和 <codeph>Mouse.hide()</codeph> 方法可直接控制系统光标。 </p>
      
      </apiDesc></apiOperationDetail></apiOperation><apiValue id="mx.managers:CursorManager:NO_CURSOR"><apiName>NO_CURSOR</apiName><shortdesc>
      一个常量，表示当由于 CursorManager 没有管理任何光标而显示系统光标时，currentCursorID 属性的值。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiType value="int"/></apiValueDef><apiDesc>
      一个常量，表示当由于 CursorManager 没有管理任何光标而显示系统光标时，<codeph>currentCursorID</codeph> 属性的值。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:CursorManager:currentCursorID:get"><apiName>currentCursorID</apiName><shortdesc>
      当前自定义光标的 ID；如果显示的是系统光标，则为 NO_CURSOR。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiType value="int"/></apiValueDef><apiDesc>
      当前自定义光标的 ID；如果显示的是系统光标，则为 NO_CURSOR。
      
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:CursorManager:currentCursorXOffset:get"><apiName>currentCursorXOffset</apiName><shortdesc>
      自定义光标随鼠标指针变化的 x 偏移（以像素为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiType value="Number"/><apiDefaultValue>0
      
      </apiDefaultValue></apiValueDef><apiDesc>
      自定义光标随鼠标指针变化的 x 偏移（以像素为单位）。
           
      </apiDesc></apiValueDetail></apiValue><apiValue id="mx.managers:CursorManager:currentCursorYOffset:get"><apiName>currentCursorYOffset</apiName><shortdesc>
      自定义光标随鼠标指针变化的 y 偏移（以像素为单位）。</shortdesc><prolog><asMetadata><apiVersion><apiLanguage version="3.0"/><apiPlatform description="" name="Flash" version="9"/><apiPlatform description="" name="AIR" version="1.1"/><apiTool description="" name="Flex" version="3"/></apiVersion></asMetadata></prolog><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiType value="Number"/><apiDefaultValue>0
      
      </apiDefaultValue></apiValueDef><apiDesc>
      自定义光标随鼠标指针变化的 y 偏移（以像素为单位）。
     
      </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage>